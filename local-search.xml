<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JS 事件机制</title>
    <link href="/2021/02/05/JS-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/02/05/JS-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="JS-中的事件机制"><a href="#JS-中的事件机制" class="headerlink" title="JS 中的事件机制"></a>JS 中的事件机制</h1><h2 id="1、事件冒泡与事件捕获"><a href="#1、事件冒泡与事件捕获" class="headerlink" title="1、事件冒泡与事件捕获"></a>1、事件冒泡与事件捕获</h2><blockquote><p><strong>事件冒泡</strong>和<strong>事件捕获</strong>分别由<strong>微软</strong>和<strong>网景</strong>公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。参考下面代码：</p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span>        Click me!     <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h3 id="1-1-事件冒泡"><a href="#1-1-事件冒泡" class="headerlink" title="1.1 事件冒泡"></a>1.1 事件冒泡</h3><p>微软提出**事件冒泡(event bubbling)**的事件流，由内向外传播事件。也就是说，事件从最内层的元素开始发生，一直向上传播，直到document对象。</p><p>因此，在事件冒泡的概念下，p元素上发生的click时间的顺序是<code>p -&gt; div -&gt; body -&gt; html -&gt; document</code></p><h3 id="1-2-事件捕获"><a href="#1-2-事件捕获" class="headerlink" title="1.2 事件捕获"></a>1.2 事件捕获</h3><p>网景提出了另一种事件流名为**事件捕获(event capturing)**，与事件冒泡相反，事件会从最外层开始发生，直到最内层的具体元素。</p><p>因此，在时间捕获的概念下，p元素上发生的click时间的顺序是<code>document -&gt; html -&gt; body -&gt; div -&gt; p</code></p><h3 id="1-3-addEventListener-的第三个参数"><a href="#1-3-addEventListener-的第三个参数" class="headerlink" title="1.3 addEventListener 的第三个参数"></a>1.3 addEventListener 的第三个参数</h3><p>网景 和 微软 曾经的战争还是比较火热的，当时， 网景主张捕获方式，微软主张冒泡方式。后来 w3c 采用折中的方式，平息了战火，制定了统一的标准——<strong>先捕获再冒泡</strong>。</p><p>addEventListener 的第三个参数就是为冒泡和捕获准备的。</p><pre><code class="hljs js">element.addEventListener(event, <span class="hljs-function"><span class="hljs-keyword">function</span>, <span class="hljs-title">useCapture</span>)</span></code></pre><ul><li>event：需要绑定的事件</li><li>function：触发事件之后要执行的函数</li><li>useCapture：默认值为<code>false</code>，表示在<strong>事件冒泡阶段调</strong>用事件处理函数；如果参数为<code>true</code>，则表示在<strong>事件捕获阶段</strong>调用处理函数。</li></ul><h2 id="2、实例讲解"><a href="#2、实例讲解" class="headerlink" title="2、实例讲解"></a>2、实例讲解</h2><h3 id="2-1-冒泡的案例"><a href="#2-1-冒泡的案例" class="headerlink" title="2.1 冒泡的案例"></a>2.1 冒泡的案例</h3><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;s1&quot;</span>&gt;s1&lt;div id=<span class="hljs-string">&quot;s2&quot;</span>&gt;s2&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    s1.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;s1 冒泡事件&quot;</span>);&#125;, <span class="hljs-literal">false</span>);s2.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;s2 冒泡事件&quot;</span>);&#125;, <span class="hljs-literal">false</span>);&lt;/script&gt;</code></pre><p>当点击s2时，执行结果如下：</p><p><img src="https://i.loli.net/2021/02/04/UmbEPeJ4DdYxQKM.png" alt="image-20210204170104285">    </p><h3 id="2-2-捕获的案例"><a href="#2-2-捕获的案例" class="headerlink" title="2.2 捕获的案例"></a>2.2 捕获的案例</h3><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;s1&quot;</span>&gt;s1&lt;div id=<span class="hljs-string">&quot;s2&quot;</span>&gt;s2&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    s1.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;s1 捕获事件&quot;</span>);&#125;, <span class="hljs-literal">true</span>);s2.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;s2 捕获事件&quot;</span>);&#125;, <span class="hljs-literal">true</span>);&lt;/script&gt;</code></pre><p>当点击s2的时，执行结果如下：</p><p><img src="https://i.loli.net/2021/02/04/agdxsHc1KCA7JhU.png" alt="image-20210204170407992">    </p><h2 id="3、事件捕获vs事件冒泡"><a href="#3、事件捕获vs事件冒泡" class="headerlink" title="3、事件捕获vs事件冒泡"></a>3、事件捕获vs事件冒泡</h2><p>​    当事件捕获和事件冒泡一起存在时，记被点击的DOM节点为target节点。</p><pre><code>1. document 往 target 节点，捕获前进，遇到注册的捕获事件立即触发执行；2. 到达 target 节点，触发事件（对于target节点，先捕获还是先冒泡取决于捕获事件和冒泡事件的注册顺序，先注册先执行）；3. target 节点往 document 方向，冒泡前进，遇到注册的冒泡时间立即触发。</code></pre><h3 id="3-1-总结下就是"><a href="#3-1-总结下就是" class="headerlink" title="3.1 总结下就是"></a>3.1 总结下就是</h3><ul><li><p>对于非 target 节点则先执行捕获再执行冒泡</p></li><li><p>对于 target 节点则是执行先注册的事件，无论冒泡还是捕获</p><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;s1&quot;</span>&gt;s1&lt;div id=<span class="hljs-string">&quot;s2&quot;</span>&gt;s2&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    s1.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;s1 冒泡事件&quot;</span>);&#125;, <span class="hljs-literal">false</span>);s2.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;s2 冒泡事件&quot;</span>);&#125;, <span class="hljs-literal">false</span>);s1.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;s1 捕获事件&quot;</span>);&#125;, <span class="hljs-literal">true</span>);s2.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;s2 捕获事件&quot;</span>);&#125;, <span class="hljs-literal">true</span>);&lt;/script&gt;</code></pre><p>当点击s2的时候，执行结果如下：</p><p><img src="https://i.loli.net/2021/02/04/Hg5aFLb8rYl2tnM.png" alt="image-20210204215446278">    </p><p>分析执行结果：</p><ol><li><p>点击s2，click事件从<code>document -&gt; html -&gt; body -&gt; s1 -&gt; s2</code>(捕获前进)，在s1上发现了捕获注册，则输出<strong>“s1 捕获事件”</strong>；</p></li><li><p>到达s2，到达目的target节点；</p></li><li><p>s2上注册了冒泡和捕获事件，先注册冒泡后注册捕获，则先执行冒泡事件，输出<strong>“s2 冒泡事件”</strong>；</p></li><li><p>再在s2上执行捕获事件，输出<strong>“s2 捕获事件”</strong>；</p></li><li><p>下面进入冒泡阶段，按照<code>s1 -&gt; s2 -&gt; body -&gt; html -&gt; document</code>(冒泡前进)</p></li><li><p>在s1上发现了冒泡事件，则输出<strong>“s1 冒泡事件”</strong>。</p></li></ol></li></ul><h2 id="4-事件冒泡与事件捕获应用-事件代理"><a href="#4-事件冒泡与事件捕获应用-事件代理" class="headerlink" title="4. 事件冒泡与事件捕获应用:事件代理"></a>4. 事件冒泡与事件捕获应用:事件代理</h2><h4 id="4-1-案例"><a href="#4-1-案例" class="headerlink" title="4.1 案例"></a>4.1 案例</h4><p>  在实际的开发当中，利用事件流的特性，我们可以使用一种叫做事件代理的方法。</p>  <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;color-list&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>red<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>yellow<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>blue<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>green<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>black<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>white<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><p>  如果点击页面中的li元素，然后输出li当中的颜色，我们通常会这样写:</p>  <pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">var</span> color_list = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;color-list&#x27;</span>); <span class="hljs-keyword">var</span> colors = color_list.getElementsByTagName(<span class="hljs-string">&#x27;li&#x27;</span>); <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;colors.length;i++)&#123; colors[i].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,showColor,<span class="hljs-literal">false</span>); &#125;; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showColor</span>(<span class="hljs-params">e</span>)</span>&#123; <span class="hljs-keyword">var</span> x = e.target; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The color is &quot;</span> + x.innerHTML); &#125;;&#125;)();</code></pre><p>  利用事件流的特性，我们只绑定一个事件处理函数也可以完成：</p>  <pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">var</span> color_list =<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;color-list&#x27;</span>);  color_list.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,showColor,<span class="hljs-literal">false</span>);  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showColor</span>(<span class="hljs-params">e</span>)</span>&#123;  <span class="hljs-keyword">var</span> x = e.target;  <span class="hljs-keyword">if</span>(x.nodeName.toLowerCase() === <span class="hljs-string">&#x27;li&#x27;</span>)&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The color is &#x27;</span> + x.innerHTML);  &#125; &#125;&#125;)();</code></pre><p>  使用事件代理的好处不仅在于将多个事件处理函数减为一个，而且对于不同的元素可以有不同的处理方法。假如上述列表元素当中添加了其他的元素（如：a、span等），我们不必再一次循环给每一个元素绑定事件，直接修改事件代理的事件处理函数即可。</p><h2 id="5-冒泡还是捕获？"><a href="#5-冒泡还是捕获？" class="headerlink" title="5. 冒泡还是捕获？"></a>5. 冒泡还是捕获？</h2><p>  对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。</p><h4 id="5-1-IE浏览器兼容"><a href="#5-1-IE浏览器兼容" class="headerlink" title="5.1 IE浏览器兼容"></a>5.1 IE浏览器兼容</h4><p>  IE浏览器对<strong>addEventListener</strong>兼容性并不算太好，只有IE9以上可以使用。</p><p>  <img src="https://i.loli.net/2021/02/05/6xwGnWvNPdpDrU2.png">`</p><p>  要兼容旧版本的IE浏览器，可以使用IE的<strong>attachEvent</strong>函数</p>  <pre><code class="hljs js">object.attachEvent(event, <span class="hljs-function"><span class="hljs-keyword">function</span>)</span></code></pre><p>  两个参数与<strong>addEventListener</strong>相似，分别是事件和处理函数，默认是事件冒泡阶段调用处理函数，要注意的是，<strong>写事件名时候要加上”on”前缀（”onload”、”onclick”等）</strong>。</p><h2 id="6-事件注意点"><a href="#6-事件注意点" class="headerlink" title="6. 事件注意点"></a>6. 事件注意点</h2><ul><li><p>事件分为三个阶段：   事件捕获 –&gt;  事件目标 –&gt;  事件冒泡</p></li><li><p>事件捕获：事件发生时（onclick,onmouseover……）首先发生在document上，然后依次传递给body、……最后到达目的节点（即事件目标）。</p></li><li><p>事件冒泡：事件到达事件目标之后不会结束，会逐层向上冒泡，直至document对象，跟事件捕获相反</p><h4 id="6-1-常用技巧"><a href="#6-1-常用技巧" class="headerlink" title="6.1 常用技巧"></a>6.1 常用技巧</h4></li></ul><ol><li><p>onlick –&gt;事件冒泡，重写onlick会覆盖之前属性，没有兼容性问题</p><pre><code class="hljs js">ele.onclik = <span class="hljs-literal">null</span>;   <span class="hljs-comment">//解绑单击事件，将onlick属性设为null即可</span></code></pre></li><li><p>addEventListener(event.type, handle, boolean); IE8及以下不支持，属于DOM2级的方法，可添加多个方法不被覆盖</p><pre><code class="hljs js"><span class="hljs-comment">//事件类型没有on，false 表示在事件第三阶段（冒泡）触发，true表示在事件第一阶段（捕获）触发。 如果handle是同一个方法，只执行一次。</span>ele.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; &#125;, <span class="hljs-literal">false</span>);  <span class="hljs-comment">//解绑事件，参数和绑定一样</span>ele.removeEventListener(event.type, handle, boolean);</code></pre></li><li><p>attachEvent(event.type, handle ); IE特有，兼容IE8及以下，可添加多个事件处理程序，只支持冒泡阶段</p><pre><code class="hljs js"><span class="hljs-comment">//如果handle是同一个方法，绑定几次执行几次，这点和addEventListener不同,事件类型要加on,例如onclick而不是click</span>ele.attachEvent(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; &#125;); <span class="hljs-comment">//解绑事件，参数和绑定一样</span>ele.detachEvent(<span class="hljs-string">&quot;onclick&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; &#125;);</code></pre></li><li><p>默认事件行为：href=””链接，submit表单提交等</p><p><strong>阻止默认事件：</strong><br>（1）<strong>return false;</strong> 阻止独享属性（通过on这种方式）绑定的事件的默认事件</p><pre><code class="hljs js">ele.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    ……                         <span class="hljs-comment">//你的代码</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;              <span class="hljs-comment">//通过返回false值阻止默认事件行为</span>&#125;;</code></pre><p>（2）<strong>event.preventDefault( );</strong> 阻止通过 <strong>addEventListener( )</strong> 添加的事件的默认事件</p><pre><code class="hljs js">element.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;    <span class="hljs-keyword">var</span> event = e || <span class="hljs-built_in">window</span>.event;    ……    event.preventDefault( );      <span class="hljs-comment">//阻止默认事件</span>&#125;,<span class="hljs-literal">false</span>);</code></pre></li></ol><pre><code> （3）**event.returnValue = false;** 阻止通过 **attachEvent( )** 添加的事件的默认事件 <pre><code class="hljs js">element.attachEvent(<span class="hljs-string">&quot;onclick&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;    <span class="hljs-keyword">var</span> event = e || <span class="hljs-built_in">window</span>.event;    ……    event.returnValue = <span class="hljs-literal">false</span>;       <span class="hljs-comment">//阻止默认事件</span>&#125;,<span class="hljs-literal">false</span>);</code></pre></code></pre><ol start="5"><li><p>接下来我们把事件绑定以及事件解绑封装成为一个函数，兼容浏览器，包括IE6及以上</p><pre><code class="hljs js"><span class="hljs-comment">// 事件绑定</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">element, eType, handle, bol</span>) </span>&#123;    <span class="hljs-keyword">if</span>(element.addEventListener)&#123;           <span class="hljs-comment">//如果支持addEventListener</span>        element.addEventListener(eType, handle, bol);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(element.attachEvent)&#123;          <span class="hljs-comment">//如果支持attachEvent</span>        element.attachEvent(<span class="hljs-string">&quot;on&quot;</span>+eType, handle);    &#125;<span class="hljs-keyword">else</span>&#123;                                  <span class="hljs-comment">//否则使用兼容的onclick绑定</span>        element[<span class="hljs-string">&quot;on&quot;</span>+eType] = handle;    &#125;&#125;</code></pre><pre><code class="hljs js"><span class="hljs-comment">// 事件解绑</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeEvent</span>(<span class="hljs-params">element, eType, handle, bol</span>) </span>&#123;    <span class="hljs-keyword">if</span>(element.addEventListener)&#123;        element.removeEventListener(eType, handle, bol);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(element.attachEvent)&#123;        element.detachEvent(<span class="hljs-string">&quot;on&quot;</span>+eType, handle);    &#125;<span class="hljs-keyword">else</span>&#123;        element[<span class="hljs-string">&quot;on&quot;</span>+eType] = <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre></li></ol><p>  <strong>A.● 事件冒泡、事件捕获阻止：</strong></p>  <pre><code class="hljs js">event.stopPropagation( );                <span class="hljs-comment">// 阻止事件的进一步传播，包括（冒泡，捕获），无参数</span>event.cancelBubble = <span class="hljs-literal">true</span>;             <span class="hljs-comment">// true 为阻止冒泡</span></code></pre><p>  <strong>B.● 事件委托:</strong><br>   利用事件冒泡的特性，将里层的事件委托给外层事件，根据event对象的属性进行事件委托，改善性能。<br>   使用事件委托能够避免对特定的每个节点添加事件监听器；事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。</p><p>  来个例子吧，如果要单独点击table里面的td，普通做法是for循环给每个td绑定事件，td少的话性能什么差别，td如果多了，就不行了，我们使用事件委托:</p>  <pre><code class="hljs html"> <span class="hljs-comment">&lt;!-- HTML --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;out&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor: pointer;&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    　　<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>table01<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    　　<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>table02<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    　　<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>table03<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    　　<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>table04<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    　　<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>table05<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    　　<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>table06<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    　　<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>table07<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    　　<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>table08<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    　　<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>table09<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    　　<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>table10<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre>  <pre><code class="hljs js"><span class="hljs-keyword">var</span> out = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;out&quot;</span>);      <span class="hljs-keyword">if</span>(out.addEventListener)&#123;          out.addEventListener(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;              <span class="hljs-keyword">var</span> e = e||<span class="hljs-built_in">window</span>.event;              <span class="hljs-comment">//IE没有e.target，有e.srcElement</span>              <span class="hljs-keyword">var</span> target = e.target||e.srcElement;             <span class="hljs-comment">//判断事件目标是否是td，是的话target即为目标节点td</span>            <span class="hljs-keyword">if</span>(target.tagName.toLowerCase()==<span class="hljs-string">&quot;td&quot;</span>)&#123;                 changeStyle(target);                 <span class="hljs-built_in">console</span>.log(target.innerHTML);             &#125;         &#125;,<span class="hljs-literal">false</span>);     &#125;<span class="hljs-keyword">else</span>&#123;         out.attachEvent(<span class="hljs-string">&quot;onclick&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;             <span class="hljs-keyword">var</span> e = e||<span class="hljs-built_in">window</span>.event;             <span class="hljs-comment">//IE没有e.target，有e.srcElement</span>             <span class="hljs-keyword">var</span> target = e.target||e.srcElement;             <span class="hljs-comment">//判断事件目标是否是td，是的话target即为目标节点td</span>             <span class="hljs-keyword">if</span>(target.tagName.toLowerCase()==<span class="hljs-string">&quot;td&quot;</span>)&#123;                 changeStyle(target);                 <span class="hljs-built_in">console</span>.log(target.innerHTML);             &#125;         &#125;);     &#125;; &#125;; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeStyle</span>(<span class="hljs-params">ele</span>)</span>&#123;     ele.innerHTML = <span class="hljs-string">&quot;已点击&quot;</span>     ele.style.background=<span class="hljs-string">&quot;#900&quot;</span>;     ele.style.color = <span class="hljs-string">&quot;#fff&quot;</span>; &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10-21 复习点</title>
    <link href="/2020/10/23/10-21-%E5%A4%8D%E4%B9%A0%E7%82%B9/"/>
    <url>/2020/10/23/10-21-%E5%A4%8D%E4%B9%A0%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<ul><li><p><strong>HTTP 协议</strong></p><ul><li>超文本传输协议：从万维网服务器传输超文本到本地浏览器的传送协议</li><li>HTTP基于TCP/IP通信协议来传递数据(HTML文件、图片文件、查询结果等)</li></ul></li><li><p><strong>flex布局</strong></p><blockquote><p>容器的属性</p></blockquote><ul><li><p>flex-direction：决定主轴的方向，默认为 row (水平)</p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;    <span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse&#125;<span class="hljs-selector-tag">row</span>（默认值）：主轴为水平方向，起点在左端。<span class="hljs-selector-tag">row-reverse</span>：主轴为水平方向，起点在右端。<span class="hljs-selector-tag">column</span>：主轴为垂直方向，起点在上沿。<span class="hljs-selector-tag">column-reverse</span>：主轴为垂直方向，起点在下沿。</code></pre></li><li><p>flex-wrap：定义一条轴线不下，如何换行</p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;    <span class="hljs-attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse&#125;<span class="hljs-selector-tag">nowrap</span>（默认值）：不换行<span class="hljs-selector-tag">wrap</span>：换行<span class="hljs-selector-tag">wrap-reverse</span>：换行，第一行在下方</code></pre></li><li><p>flex-flow：是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap </p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<span class="hljs-attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;&#125;</code></pre></li><li><p>justify-content：项目在主轴上的对齐方式</p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around&#125;<span class="hljs-selector-tag">flex-start</span>（默认值）：左对齐<span class="hljs-selector-tag">flex-end</span>：右对齐<span class="hljs-selector-tag">center</span>： 居中<span class="hljs-selector-tag">space-between</span>：两端对齐，项目之间的间隔都相等。<span class="hljs-selector-tag">space-around</span>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</code></pre></li><li><p>align-items：项目在交叉轴上如何对齐</p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;&#125;<span class="hljs-selector-tag">flex-start</span>：交叉轴的起点对齐。<span class="hljs-selector-tag">flex-end</span>：交叉轴的终点对齐。<span class="hljs-selector-tag">center</span>：交叉轴的中点对齐。<span class="hljs-selector-tag">baseline</span>: 项目的第一行文字的基线对齐。<span class="hljs-selector-tag">stretch</span>（默认值）：如果项目未设置高度或设为<span class="hljs-selector-tag">auto</span>，将占满整个容器的高度。</code></pre></li></ul><blockquote><p>项目的属性</p></blockquote><ul><li><p>order：定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">order</span>: &lt;integer&gt;;&#125;</code></pre></li><li><p>flex-grow：定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-grow</span>: &lt;number&gt;; <span class="hljs-comment">/* default 0 */</span>&#125;</code></pre></li><li><p>flex-shrink：定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;; <span class="hljs-comment">/* default 1 */</span>&#125;</code></pre></li><li><p>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span>&#125;</code></pre><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p></li><li><p>flex：是 flex-grow,  flex-shrink 和 flex-basis的简写，默认值为 0 1 auto。后两个属性可选。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex</span>: none | [ &lt;<span class="hljs-string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="hljs-string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="hljs-string">&#x27;flex-basis&#x27;</span>&gt; ]&#125;</code></pre><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p></li><li><p>align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;&#125;</code></pre></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10-20 复习点</title>
    <link href="/2020/10/23/10-20-%E5%A4%8D%E4%B9%A0%E7%82%B9/"/>
    <url>/2020/10/23/10-20-%E5%A4%8D%E4%B9%A0%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<ul><li><p><strong>ES6新特性</strong></p><ul><li>新增let和const声明变量，实现了块级作用域</li><li>新增箭头函数</li><li>新增了模块化机制</li><li>引入promise解决异步回调问题</li><li>引入Class作为对象的模板，实现更好的面向对象编程</li><li>引入新的数据类型symbol，新的数据结构set和map</li></ul></li><li><p><strong>闭包</strong></p></li><li><p><strong>Promise</strong></p></li><li><p><strong>class类</strong></p></li><li><p><strong>原生语法实现继承</strong></p></li><li><p><strong>数组的方法及遍历方法 …</strong></p><ul><li><p>push()：添加元素到数组末尾，返回新的长度</p></li><li><p>pop()：删除数组末尾元素，返回被删除的元素</p></li><li><p>unshift()：添加元素到数组的头部，返回新的长度</p></li><li><p>shift()：删除数组开头元素，返回被删除的元素</p></li><li><p>indexOf()：查看某个元素在数组中的位置</p></li><li><p>splice(start, num, value)：实现增删改操作（start开始下标，num删除元素个数，value插入或替换的元素）</p></li><li><p>slice(start, end)：浅拷贝数组并返回拷贝后的新数组</p></li><li><p>concat()：连接数组，不对原数组产生影响</p></li><li><p>join()：将数组转换为字符串，不对原数组产生影响</p></li><li><p>reverse()：反转数组，直接修改原数组</p></li><li><p>sort()：对数组中元素排序</p><pre><code class="hljs javascript">arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<span class="hljs-keyword">return</span> a-b;    <span class="hljs-comment">//升序排列</span>&#125;);</code></pre></li></ul></li></ul><ul><li><p><strong>深拷贝与浅拷贝</strong></p><ul><li><p>浅拷贝：只是拷贝一层，更深层次对象级别的只拷贝引用</p><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> obj2)&#123;<span class="hljs-comment">// k 是属性名 obj2[k] 是属性值</span>obj1[k] = obj2[k];&#125;<span class="hljs-built_in">Object</span>.assign(obj1,obj2);   <span class="hljs-comment">// ES6中的语法糖</span></code></pre></li><li><p>深拷贝：深拷贝拷贝多层，每一级别的数据都会拷贝</p><pre><code class="hljs javascript"><span class="hljs-comment">// 封装深拷贝函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepCopy</span> (<span class="hljs-params">newobj, oldobj</span>) </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> oldobj) &#123;        <span class="hljs-keyword">let</span> item = oldobj[k];    <span class="hljs-comment">// 数组    </span><span class="hljs-keyword">if</span> (item <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;            newobj[k] = [];            deepCopy(newobj[k], item);        &#125;    <span class="hljs-comment">// 对象    </span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) &#123;            newobj[k] = &#123;&#125;;            deepCopy(newobj[k], item);        &#125;        <span class="hljs-comment">// 基本数据类型</span>        <span class="hljs-keyword">else</span> &#123;            newobj[k] = item;        &#125;&#125;&#125;</code></pre></li></ul></li></ul><ul><li><p><strong>判断类型的方法</strong></p><ul><li>typeof：返回类型</li><li>A instanceof B：可以判断A是不是B的实例，返回一个布尔值，由构造类型判断出数据类型</li></ul></li><li><p><strong>改变this的方法</strong></p><blockquote><p>call和apply作用：改变this的指向；借用别的对象的方法；调用函数</p></blockquote><ul><li>call()：第一个参数为改变指向的对象，之后的参数为arg1,arg2…形式传入，函数立即执行</li><li>apply()：第一个参数为改变指向的对象，之后的参数为[arg1,arg2…]数组的形式传入，函数立即执行</li><li>bind()：返回一个新的函数，函数不会立即执行</li></ul></li><li><p><strong>面向对象的特性</strong></p><ul><li>封装性：将代码抽离，将对象运行所需的资源封装在程序对象中，例如：类是封装对象的属性和行为；方法是封装具体的逻辑功能。</li><li>继承性：继承可以使得子类具有父类的各种公共属性和资源，而不需要再次编写相同的代码。</li><li>多态性：允许子类 ‘重构’ 和 ‘重写’</li></ul></li><li><p><strong>v-model功能实现</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&#x27;text&#x27;</span> <span class="hljs-attr">:value</span> = <span class="hljs-string">&#x27;message&#x27;</span> @<span class="hljs-attr">input</span> = <span class="hljs-string">&#x27;message = $event.target.value&#x27;</span>&gt;</span></code></pre></li></ul><ul><li><p><strong>flex布局及垂直居中</strong></p><pre><code class="hljs css">1.定位 + <span class="hljs-selector-tag">margin</span><span class="hljs-selector-class">.div</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">margin</span>: auto;&#125;2<span class="hljs-selector-class">.transform</span>方案<span class="hljs-selector-class">.div</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);&#125;3<span class="hljs-selector-class">.flex</span>布局<span class="hljs-selector-class">.box</span> &#123;    <span class="hljs-attribute">display</span>: flex;    <span class="hljs-attribute">justify-content</span>: center;    <span class="hljs-attribute">align-item</span>: center;&#125;4<span class="hljs-selector-class">.display</span>: <span class="hljs-selector-tag">table-cell</span> 无兼容性问题<span class="hljs-selector-class">.box</span> &#123;<span class="hljs-attribute">position</span>: relative;<span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;<span class="hljs-attribute">display</span>: table-cell;<span class="hljs-attribute">text-align</span>: center;<span class="hljs-attribute">vertical-align</span>: middle;&#125;</code></pre></li><li><p><strong>元素隐藏的方法</strong></p><ul><li>display: none    真正意义上的隐藏，模型消失且不占据空间，类似于删除；</li><li>visibility:  hidden    元素隐藏，占据空间，不会触发事件</li><li>opacity： 0          透明度为0，不显示，占据空间，会触发事件</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10-19 复习点</title>
    <link href="/2020/10/23/10-19-%E5%A4%8D%E4%B9%A0%E7%82%B9/"/>
    <url>/2020/10/23/10-19-%E5%A4%8D%E4%B9%A0%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="前端复习"><a href="#前端复习" class="headerlink" title="前端复习"></a>前端复习</h1><h2 id="一、自我介绍"><a href="#一、自我介绍" class="headerlink" title="一、自我介绍"></a>一、<strong>自我介绍</strong></h2><h2 id="二、计算机网络"><a href="#二、计算机网络" class="headerlink" title="二、计算机网络"></a>二、计算机网络</h2><h3 id="1-TCP-IP协议的基本框架"><a href="#1-TCP-IP协议的基本框架" class="headerlink" title="1.TCP/IP协议的基本框架"></a>1.TCP/IP协议的基本框架</h3><img src="https://images2015.cnblogs.com/blog/849589/201706/849589-20170628002845914-1085185628.png"><h3 id="2-应用层的网络协议"><a href="#2-应用层的网络协议" class="headerlink" title="2.应用层的网络协议"></a>2.应用层的网络协议</h3><ul><li>HTTP：超文本传输协议</li><li>FTP：文件传输协议</li><li>SMTP：简单邮件传输协议</li><li>DNS：域名系统</li></ul><h3 id="3-地址"><a href="#3-地址" class="headerlink" title="3.地址"></a>3.地址</h3><ul><li>MAC地址：数据链路中的地址，用来识别同一链路中的不同计算机</li><li>IP地址：网络层引入了IP协议，制定了一套新地址，用来识别连接到网络的主机和服务器</li><li>程序地址(端口号)：识别同一台计算机中通信的不同应用该程序</li></ul><h3 id="4-全流程"><a href="#4-全流程" class="headerlink" title="4.全流程"></a>4.全流程</h3><ul><li>链路层：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据；</li><li>网络层：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发；</li><li>传输层：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序；</li><li>应用层：定义数据格式，并按照对应的格式解读数据。</li></ul><p>把每层模型的职责串联起来,当你输入一个网址并按下回车键的时候:</p><blockquote><p>应用层协议对该请求包做了格式定义 —-&gt; 传输层协议加上了双方的端口号，确认了双方通信的应用程序 —-&gt; 网络层加上了双方的IP地址，确认了双方的网络位置 —-&gt; 链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。</p><p>而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。</p></blockquote><h3 id="5-TCP三次握手"><a href="#5-TCP三次握手" class="headerlink" title="5.TCP三次握手"></a>5.TCP三次握手</h3><h2 id="三、HTTP-HTTPS-浏览器"><a href="#三、HTTP-HTTPS-浏览器" class="headerlink" title="三、HTTP/HTTPS/浏览器"></a>三、HTTP/HTTPS/浏览器</h2><h3 id="1-HTTP常见状态码"><a href="#1-HTTP常见状态码" class="headerlink" title="1.HTTP常见状态码"></a>1.HTTP常见状态码</h3><blockquote><p>按第一个数字分类：1表示信息，2表示成功，3表示重定向，4表示客户端错误，5表示服务器错误</p></blockquote><table><thead><tr><th>状态码</th><th align="center">含义</th></tr></thead><tbody><tr><td>200 OK</td><td align="center">请求成功。一般用于get和post请求</td></tr><tr><td>304 Not Modified</td><td align="center">未修改。所请求的资源未修改，服务器返回此状态码，不会返回任何资源</td></tr><tr><td>400 Bad Request</td><td align="center">客户端请求的语法错误，服务器无法理解（产生原因：前端提交的数据在后台找不到与之相对应的实体）</td></tr><tr><td>401 Unauthorized</td><td align="center">当前请求需要用户验证</td></tr><tr><td>403 Forbidden</td><td align="center">服务器已经收到请求，但拒绝执行</td></tr><tr><td>404 Not Found</td><td align="center">服务器无法根据用户的请求找到资源</td></tr><tr><td>500 Internal Server Error</td><td align="center">服务器内部错误，无法完成请求</td></tr></tbody></table><h3 id="2-get方法和post方法"><a href="#2-get方法和post方法" class="headerlink" title="2.get方法和post方法"></a>2.get方法和post方法</h3><ul><li>get：请求指定的页面信息并返回响应主体，一般用于数据的读取</li><li>post： 向指定资源提交数据，请求服务器去处理</li></ul><h3 id="3-HTTP与HTTPS的区别"><a href="#3-HTTP与HTTPS的区别" class="headerlink" title="3.HTTP与HTTPS的区别"></a>3.HTTP与HTTPS的区别</h3><ul><li><p>HTTP：超文本传输协议，TCP协议的一种，用于从WWW服务器传输超文本到浏览器的一种协议</p></li><li><p>HTTPS：HTTP+SSL，是HTTP的安全版，加入SSL层实现加密传输和身份认证</p></li><li><p>区别：</p><ul><li>HTTP传输的数据是未加密的，即明文传输；HTTPS是具有安全性的SSL加密传输协议；</li><li>HTTPS需要使用SSL证书；HTTP不用；</li><li>端口号不同，HTTP端口号80；HTTPS端口号443；</li><li>HTTPS基于传输层；HTTP基于应用层。</li></ul></li></ul><h3 id="4-浏览器"><a href="#4-浏览器" class="headerlink" title="4.浏览器"></a>4.浏览器</h3><p><strong>1).什么是URL</strong></p><ul><li><p>URL指的是统一资源定位符，即给定的一个独特资源在web中的地址</p></li><li><p>组成部分：协议+域名+端口+路径</p></li></ul><p><strong>2).什么是BOM</strong></p><ul><li>location对象：获取或设置窗口的URL，并且可以解析URL；</li><li>history对象：记录用户曾经浏览过的页面（URL），并可以实现浏览器的前进与后退相似导航功能；</li><li>navigator对象：包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。</li></ul><p><strong>3).Cookie的作用</strong></p><ul><li>保存用户的登录状态：如一段时间内免登陆</li><li>跟踪用户行为：如保存某些设置、天气访问地区</li></ul><p><strong>4).Cookie和Session的共同点和区别</strong></p><p>共同点：都是用来跟踪浏览器用户身份的会话方式</p><p>区别：</p><ul><li>cookie数据保存在浏览器，session数据保存在服务器</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑安全性使用session</li><li>session会在一定时间内保存在服务器上，当访问增多是会占用服务器性能，考虑性能使用cookie</li></ul><p><strong>5).输入URL到页面加载显示完成发生了什么</strong></p><p>DNS解析</p><p>TCP连接</p><p>发送HTTP请求</p><p>服务器处理请求并返回HTTP报文</p><p>浏览器解析渲染页面</p><p>连接结束</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>仿网易云播放器_vue</title>
    <link href="/2020/10/15/%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E6%92%AD%E6%94%BE%E5%99%A8-vue/"/>
    <url>/2020/10/15/%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E6%92%AD%E6%94%BE%E5%99%A8-vue/</url>
    
    <content type="html"><![CDATA[<h1 id="仿网易云音乐播放器"><a href="#仿网易云音乐播放器" class="headerlink" title="仿网易云音乐播放器"></a>仿网易云音乐播放器</h1><p>本项目使用VSCode工具编码。是一个vue框架的练手项目，该项目中使用到了vue-router、element-ui、vue-cli及axios等相关技术。  </p><h2 id="项目展示与说明"><a href="#项目展示与说明" class="headerlink" title="项目展示与说明"></a>项目展示与说明</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><blockquote><p>components文件下为主组件，view下是各页面视图组件  </p></blockquote><img src="https://s1.ax1x.com/2020/10/14/0IVHBD.png" width="50%" height="50%">  <h3 id="发现音乐页面"><a href="#发现音乐页面" class="headerlink" title="发现音乐页面"></a>发现音乐页面</h3><blockquote><p>主页面</p></blockquote><p><img src="https://s1.ax1x.com/2020/10/14/0IAoP1.png" alt="0IAoP1.png">  </p><h3 id="推荐歌单页面"><a href="#推荐歌单页面" class="headerlink" title="推荐歌单页面"></a>推荐歌单页面</h3><blockquote><p>头部为精品歌单，主体部分为推荐歌单，且可根据类型切换推荐（默认为全部）</p></blockquote><p><img src="https://s1.ax1x.com/2020/10/14/0IAOqe.png" alt="0IAOqe.png">  </p><h3 id="最新音乐页面"><a href="#最新音乐页面" class="headerlink" title="最新音乐页面"></a>最新音乐页面</h3><blockquote><p>根据分类罗列50首最新音乐</p></blockquote><p><img src="https://s1.ax1x.com/2020/10/14/0IALrD.png" alt="0IALrD.png">  </p><h3 id="最新mv页面"><a href="#最新mv页面" class="headerlink" title="最新mv页面"></a>最新mv页面</h3><blockquote><p>根据类型切换显示当前最新mv</p></blockquote><p><img src="https://s1.ax1x.com/2020/10/14/0IAT8x.png" alt="0IAT8x.png">  </p><h3 id="搜索页面"><a href="#搜索页面" class="headerlink" title="搜索页面"></a>搜索页面</h3><blockquote><p>根据搜索框输入内容，显示搜索结果（单曲、歌单和mv）  </p></blockquote><p><img src="https://s1.ax1x.com/2020/10/14/0IAHxK.png" alt="0IAHxK.png">  </p><h3 id="歌单详情页面"><a href="#歌单详情页面" class="headerlink" title="歌单详情页面"></a>歌单详情页面</h3><blockquote><p>点击歌单，进入详情页面，显示歌单详细信息</p></blockquote><p><img src="https://s1.ax1x.com/2020/10/14/0IA4a9.png" alt="0IA4a9.png">  </p><h3 id="歌单评论页面"><a href="#歌单评论页面" class="headerlink" title="歌单评论页面"></a>歌单评论页面</h3><blockquote><p>分别显示该歌单最热评论与最新评论</p></blockquote><p><img src="https://s1.ax1x.com/2020/10/14/0IAhVJ.png" alt="0IAhVJ.png">  </p><h3 id="mv详情页面"><a href="#mv详情页面" class="headerlink" title="mv详情页面"></a>mv详情页面</h3><blockquote><p>可播放mv视频，显示mv详细信息、相关推荐及评论</p></blockquote><p><img src="https://s1.ax1x.com/2020/10/14/0IA55R.png" alt="0IA55R.png">  </p>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery笔记二_jq</title>
    <link href="/2020/09/23/jQuery%E7%AC%94%E8%AE%B0%E4%BA%8C-jq/"/>
    <url>/2020/09/23/jQuery%E7%AC%94%E8%AE%B0%E4%BA%8C-jq/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery笔记二"><a href="#jQuery笔记二" class="headerlink" title="jQuery笔记二"></a>jQuery笔记二</h1><p>接上一篇。</p><h2 id="1-CSS模块"><a href="#1-CSS模块" class="headerlink" title="1.CSS模块"></a>1.CSS模块</h2><h4 id="style样式"><a href="#style样式" class="headerlink" title="style样式"></a>style样式</h4><ul><li><code>css(styleName)</code>: 根据样式名得到对应的值</li><li><code>css(styleName, value)</code>: 设置一个样式</li><li><code>css(&#123;多个样式对&#125;)</code>: 设置多个样式</li></ul><h4 id="位置坐标"><a href="#位置坐标" class="headerlink" title="位置坐标"></a>位置坐标</h4><ul><li><code>offset()</code>: 读/写当前元素坐标(原点是页面左上角)</li><li><code>position()</code>: 读当前元素坐标(原点是父元素左上角)</li><li><code>scrollTop()/scrollLeft()</code>: 读/写元素/页面的滚动条坐标</li></ul><h4 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h4><ul><li><code>width()/height()</code>: width/height</li><li><code>innerWidth()/innerHeight()</code>: width + padding</li><li><code>outerWidth()/outerHeight()</code>: width + padding + border</li></ul><h2 id="2-筛选模块"><a href="#2-筛选模块" class="headerlink" title="2.筛选模块"></a>2.筛选模块</h2><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><blockquote><p>在jQuery对象内部的元素中找出部分匹配的元素, 并封装成新的jQuery对象返回  </p></blockquote><ul><li><code>first()</code></li><li><code>last()</code></li><li><code>eq(index)</code></li><li><code>filter(selector)</code>: 对当前元素提要求</li><li><code>not(selector)</code>: 对当前元素提要求, 并取反</li><li><code>has(selector)</code>: 对子孙元素提要求</li></ul><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><blockquote><p>查找jQuery对象内部的元素的子孙/兄弟/父母元素, 并封装成新的jQuery对象返回</p></blockquote><ul><li><code>children(selector)</code>: 子元素</li><li><code>find(selector)</code>: 后代元素</li><li><code>preAll(selector)</code>: 前的所有兄弟</li><li><code>siblings(selector)</code>: 所有兄弟</li><li><code>parent()</code>: 父元素</li></ul><h2 id="3-文档处理-CUD-模块"><a href="#3-文档处理-CUD-模块" class="headerlink" title="3.文档处理(CUD)模块"></a>3.文档处理(CUD)模块</h2><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><ul><li><code>append() / appendTo()</code>: 插入后部</li><li><code>preppend() / preppendTo()</code>: 插入前部</li><li><code>before()</code>: 插到前面</li><li><code>after()</code>: 插到后面</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li><code>remove()</code>: 将自己及内部的孩子都删除</li><li><code>empty()</code>: 掏空(自己还在)</li></ul><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><ul><li><code>replaceWith()</code></li></ul><h2 id="4-事件模块"><a href="#4-事件模块" class="headerlink" title="4.事件模块"></a>4.事件模块</h2><h4 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h4><ul><li><code>eventName(function()&#123;&#125;)</code>: 绑定对应事件名的监听,编码方便, 但只能加一个监听, 且有的事件监听不支持</li><li><code>on(&#39;eventName&#39;, function()&#123;&#125;)</code> : 通用的绑定事件监听,编码不方便, 可以添加多个监听, 且更通用</li><li>常用: <code>click</code>, <code>mouseenter/mouseleave</code> <code>mouseover/mouseout</code> <code>focus/blur</code></li><li><code>hover(function()&#123;&#125;, function()&#123;&#125;)</code></li></ul><h4 id="解绑事件"><a href="#解绑事件" class="headerlink" title="解绑事件"></a>解绑事件</h4><ul><li><code>off(&#39;eventName&#39;)</code></li></ul><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><ul><li>理解: 将子元素的事件委托给父辈元素处理<ul><li>事件监听绑定在父元素上, 但事件发生在子元素上</li><li>　事件会冒泡到父元素</li><li>但最终调用的事件回调函数的是子元素: event.target</li></ul></li><li>好处<ul><li>新增的元素没有事件监听</li><li>减少监听的数量(n==&gt;1)</li></ul></li><li>编码<ul><li><code>on(&#39;eventName&#39;, selector, function(event)&#123;&#125;)</code> // 回调函数中的this是子元素</li><li><code>off(&#39;eventName&#39;)</code></li></ul></li></ul><h4 id="事件坐标"><a href="#事件坐标" class="headerlink" title="事件坐标"></a>事件坐标</h4><ul><li><code>event.offsetX</code>: 原点是当前元素左上角</li><li><code>event.clientX</code>: 原点是窗口左上角</li><li><code>event.pageX</code>: 原点是页面左上角</li></ul><h4 id="事件相关"><a href="#事件相关" class="headerlink" title="事件相关"></a>事件相关</h4><ul><li>停止事件冒泡: <code>event.stopPropagation()</code></li><li>阻止事件的默认行为: <code>event.preventDefault()</code></li></ul><h2 id="5-动画效果"><a href="#5-动画效果" class="headerlink" title="5.动画效果"></a>5.动画效果</h2><blockquote><p>在一定的时间内, 不断改变元素样式</p></blockquote><ul><li><code>slideDown()/slideUp()/slideToggle()</code>    : 滑动动画:不断改变元素的高度</li><li><code>fadeOut()/fadeIn()/fadeToggle()</code>    : 淡入淡出: 不断改变元素的透明度(opaticy)</li><li><code>show()/hide()/toggle()</code>    : 显示隐藏</li><li><code>animate(&#123;结束时的样式&#125;, time, fun)</code></li><li><code>stop()</code>    : 停止动画</li></ul><h2 id="6-插件机制"><a href="#6-插件机制" class="headerlink" title="6.插件机制"></a>6.插件机制</h2><ul><li><p>扩展jQuery函数对象的方法</p><pre><code class="hljs js">$.extend(&#123;xxx: fuction()&#123;&#125; <span class="hljs-comment">// this是$</span>&#125;)$.xxx()</code></pre></li><li><p>扩展jQuery对象的方法</p><pre><code class="hljs js">$.fn.extend(&#123;xxx: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;  <span class="hljs-comment">// this是jQuery对象</span>&#125;)$obj.xxx()</code></pre></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>jq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery笔记一_jq</title>
    <link href="/2020/09/21/jQuery%E7%AC%94%E8%AE%B0%E4%B8%80-jq/"/>
    <url>/2020/09/21/jQuery%E7%AC%94%E8%AE%B0%E4%B8%80-jq/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery笔记一"><a href="#jQuery笔记一" class="headerlink" title="jQuery笔记一"></a>jQuery笔记一</h1><p>由于个人原因，先更新jQuery的一些基本内容，js的部分之后再补。</p><h2 id="1-了解jQuery"><a href="#1-了解jQuery" class="headerlink" title="1.了解jQuery"></a>1.了解jQuery</h2><h4 id="是什么-What"><a href="#是什么-What" class="headerlink" title="是什么: What?"></a>是什么: What?</h4><ul><li>一个JS函数库: write less, do more</li><li>封装简化DOM操作(CRUD) / Ajax  </li></ul><h4 id="为什么用它-why"><a href="#为什么用它-why" class="headerlink" title="为什么用它: why?"></a>为什么用它: why?</h4><ul><li>强大选择器: 方便快速查找DOM元素</li><li>隐式遍历(迭代): 一次操作多个元素</li><li>读写合一: 读数据/写数据用的是一个函数</li><li>链式调用: 可以通过.不断调用jQuery对象的方法</li><li>事件处理</li><li>DOM操作(CUD)</li><li>样式操作</li><li>动画</li><li>浏览器兼容  </li></ul><h4 id="如何使用-How"><a href="#如何使用-How" class="headerlink" title="如何使用: How?"></a>如何使用: How?</h4><ul><li>引入jQuery库<ul><li>本地引入与CDN远程引入</li><li>测试版与生产版(压缩版)</li></ul></li><li>使用jQuery<ul><li>使用jQuery函数: $/jQuery</li><li>使用jQuery对象: $xxx(执行$()得到的)  </li></ul></li></ul><h2 id="2-jQuery的2把利器"><a href="#2-jQuery的2把利器" class="headerlink" title="2. jQuery的2把利器"></a>2. jQuery的2把利器</h2><blockquote><p>jQuery函数: $/jQuery<br>jQuery向外暴露的就是jQuery函数, 可以直接使用</p></blockquote><h4 id="当成一般函数使用-param"><a href="#当成一般函数使用-param" class="headerlink" title="当成一般函数使用: $(param)"></a>当成一般函数使用: <code>$(param)</code></h4><ul><li><code>param</code>是<code>function</code>: 相当于<code>window.onload = function</code>(文档加载完成的监听)</li><li><code>param</code>是选择器字符串: 查找所有匹配的DOM元素, 返回包含所有DOM元素的jQuery对象</li><li><code>param</code>是DOM元素: 将DOM元素对象包装为jQuery对象返回<code>$(this)</code></li><li><code>param</code>是标签字符串: 创建标签DOM元素对象并包装为jQuery对象返回  </li></ul><h4 id="当成对象使用-xxx"><a href="#当成对象使用-xxx" class="headerlink" title="当成对象使用: $.xxx"></a>当成对象使用: $.xxx</h4><ul><li><code>each(obj/arr, function(key, value)&#123;&#125;)</code></li><li><code>trim(str)</code></li><li>jQuery对象:<ul><li>包含所有匹配的n个DOM元素的伪数组对象</li><li>执行$()返回的就是jQuery对象</li><li>基本行为:<ul><li><code>length/size()</code>: 得到dom元素的个数</li><li><code>[index]</code>: 得到指定下标对应的dom元素</li><li><code>each(function(index, domEle)&#123;&#125;)</code>: 遍历所有dom元素</li><li><code>index()</code>: 得到当前dom元素在所有兄弟中的下标  </li></ul></li></ul></li></ul><h2 id="3-选择器"><a href="#3-选择器" class="headerlink" title="3. 选择器"></a>3. 选择器</h2><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么?"></a>是什么?</h4><ul><li>有特定语法规则(css选择器)的字符串</li><li>用来查找某个/些DOM元素: $(selector)</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>基本<ul><li><code>#id</code></li><li><code>tagName/*</code></li><li><code>.class</code></li><li><code>selector1,selector2,selector3</code>: 并集</li><li><code>selector1selector2selector3</code>: 交集</li></ul></li><li>层次<ul><li>找子孙后代, 兄弟元素</li><li><code>selector1&gt;selector2</code>: 子元素</li><li><code>selector1 selector2</code>: 后代元素</li></ul></li><li>过滤<ul><li>在原有匹配元素中筛选出其中一些</li><li><code>:first</code></li><li><code>:last</code></li><li><code>:eq(index)</code></li><li><code>:lt</code></li><li><code>:gt</code></li><li><code>:odd</code></li><li><code>:even</code></li><li><code>:not(selector)</code></li><li><code>:hidden</code></li><li><code>:visible</code></li><li><code>[attrName]</code></li><li><code>[attrName=value]</code></li></ul></li><li>表单<ul><li><code>:input</code></li><li><code>:text</code></li><li><code>:checkbox</code></li><li><code>:radio</code></li><li><code>:checked</code>: 选中的  </li></ul></li></ul><ol start="4"><li>属性/文本<ul><li>操作标签的属性, 标签体文本</li><li><code>attr(name) / attr(name, value)</code>: 读写非布尔值的标签属性</li><li><code>prop(name) / prop(name, value)</code>: 读写布尔值的标签属性</li><li><code>removeAttr(name)/removeProp(name)</code>: 删除属性</li><li><code>addClass(classValue)</code>: 添加class</li><li><code>removeClass(classValue)</code>: 移除指定class</li><li><code>val() / val(value)</code>: 读写标签的value</li><li><code>html() / html(htmlString)</code>: 读写标签体文本</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>jq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用的上的网站_note</title>
    <link href="/2020/09/12/%E7%94%A8%E7%9A%84%E4%B8%8A%E7%9A%84%E7%BD%91%E7%AB%99-note/"/>
    <url>/2020/09/12/%E7%94%A8%E7%9A%84%E4%B8%8A%E7%9A%84%E7%BD%91%E7%AB%99-note/</url>
    
    <content type="html"><![CDATA[<p><strong>&emsp;蛮久没更新了，之前每学一点就更新博客有点浪费时间，所以这次等学完这点JS再抽时间一起总结更新，就先放一些平时可能用得上的网站，当是保存着。</strong>  </p><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><ul><li><p><a href="https://www.w3school.com.cn/index.html">w3school</a>：全球最大的中文 Web 技术教程。  </p></li><li><p><a href="https://www.runoob.com/">菜鸟教程</a>：不解释，类似w3school。  </p></li><li><p><a href="https://es6.ruanyifeng.com/">ES6 入门教程</a>：《ECMAScript 6 入门教程》是一本开源的 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。  </p></li></ul><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul><li><p><a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a>：国内功能很强大且图标内容很丰富的矢量图标库,提供矢量图标下载、在线存储、格式转换等功能。 </p></li><li><p><a href="https://getbootstrap.com/">Bootstrap</a>：一个CSS/HTML框架。  </p></li></ul><ul><li><p><a href="https://lanhuapp.com/web/#/item">蓝湖</a>：蓝湖是一款产品文档和设计图的共享平台,帮助互联网团队更好地管理文档和设计图。  </p></li><li><p><a href="https://imgchr.com/">路过图床</a>：图片转链接。  </p></li><li><p><a href="https://www.gaoding.com/">稿定图片</a>：图片编辑网页，可作图。  </p></li><li><p><a href="https://unbug.github.io/codelf/">AI取名</a>：智能取名，大犇推荐。  </p></li><li><p><a href="https://cubic-bezier.com/#.17,.67,.83,.67">贝塞尔曲线</a>：可设置CSS动画。  </p></li><li><p><a href="https://wallhaven.cc/">wallhaven</a>：超清壁纸网站。  </p></li></ul><blockquote><p>还发现有用得上的，会持续更新。。。。。。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组(Array)_js</title>
    <link href="/2020/09/03/%E6%95%B0%E7%BB%84-js/"/>
    <url>/2020/09/03/%E6%95%B0%E7%BB%84-js/</url>
    
    <content type="html"><![CDATA[<h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h1><p>&emsp;数组也是一个对象，它和我们普通对象功能类似，也是用来存储一些值，不同的是，普通对象是使用字符串作为属性名，数组是使用数字来作为索引来操作元素。<br>&emsp;索引：从0开始的整数。<br>&emsp;数组的存储性能比普通对象好，在开发中经常使用数组来存储数据。  </p><h2 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="1.创建数组"></a>1.创建数组</h2><ul><li><p>使用构造函数创建<br><code>var arr = new Array(10,20,30);</code>    //可以同时添加元素，将要添加的元素作为构造函数的参数传递。  </p></li><li><p>使用字面量创建<br><code>var arr1 = [1,2,3,4,5];</code>    //可以在创建时，就指定数组中的元素。  </p><blockquote><p>数组中的元素可以是任意的数据类型  </p></blockquote></li></ul><h2 id="2-数组的遍历"><a href="#2-数组的遍历" class="headerlink" title="2.数组的遍历"></a>2.数组的遍历</h2><ul><li>for循环遍历  <pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&quot;卡卡罗特&quot;</span>,<span class="hljs-string">&quot;贝吉塔&quot;</span>,<span class="hljs-string">&quot;比鲁斯&quot;</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++) &#123;<span class="hljs-built_in">console</span>.log(arr[i]);&#125;</code></pre></li></ul><ul><li>forEach()方法遍历  <blockquote><p>forEach()方法需要一个函数作为参数：<br>&emsp;像这种函数，由我们创建不由我们调用，称为回调函数;<br>&emsp;数组中有几个元素就会执行几次,每次执行时，浏览器会将遍历到的。</p><ul><li>这个方法只支持IE8以上的浏览器</li></ul></blockquote><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&quot;卡卡罗特&quot;</span>,<span class="hljs-string">&quot;贝吉塔&quot;</span>,<span class="hljs-string">&quot;比鲁斯&quot;</span>];arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,obj</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(value);&#125;);<span class="hljs-comment">//第一个参数(value)：当前正在遍历的元素；</span><span class="hljs-comment">//第二个参数(index)：当前正在遍历元素的索引；</span><span class="hljs-comment">//第三个参数(obj)：正在遍历的数组。</span></code></pre></li></ul><h2 id="3-数组的相关方法"><a href="#3-数组的相关方法" class="headerlink" title="3.数组的相关方法"></a>3.数组的相关方法</h2><p>详见 <a href="https://www.w3school.com.cn/js/js_array_methods.asp">w3school JavaScript 数组方法</a>。  </p><h2 id="4-函数和字符串的相关方法"><a href="#4-函数和字符串的相关方法" class="headerlink" title="4.函数和字符串的相关方法"></a>4.函数和字符串的相关方法</h2><p>详见 <a href="https://www.w3school.com.cn/js/index.asp">w3school JavaScript 教程</a>，这里就不过多赘述。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数与对象_js</title>
    <link href="/2020/09/01/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AF%B9%E8%B1%A1-js/"/>
    <url>/2020/09/01/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AF%B9%E8%B1%A1-js/</url>
    
    <content type="html"><![CDATA[<h1 id="函数与对象"><a href="#函数与对象" class="headerlink" title="函数与对象"></a>函数与对象</h1><p>&emsp;函数 function<br>&emsp;函数也是一个对象<br>&emsp;函数中可以封装一些功能（代码），在需要时可以执行这些功能(代码)<br>&emsp;函数中可以保存一些代码在需要的时候调用<br>&emsp;使用typeof检查一个函数对象时，会返回function  </p><h2 id="1-创建函数"><a href="#1-创建函数" class="headerlink" title="1.创建函数"></a>1.创建函数</h2><ul><li>使用<strong>构造函数</strong>创建  <blockquote><p>实际开发中很少使用构造函数来创建一个函数对象  </p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> = new <span class="hljs-title">Function</span><span class="hljs-params">(<span class="hljs-string">&quot;console.log(&#x27;这是我的第一个函数&#x27;)&quot;</span>)</span></span>;<span class="hljs-comment">//可以将要封装的代码以字符串的形式传递给构造函数</span><span class="hljs-comment">//封装到函数中的代码不会立即执行</span><span class="hljs-comment">//函数中的代码会在函数调用的时候执行</span><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//调用fun</span></code></pre></li><li>使用<strong>函数声明</strong>来创建一个函数  <blockquote><p>语法：function 函数名([形参1，形参2…形参N]) {<br>语句…;语句…;<br>}  </p></blockquote><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun2</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是我的第二个函数&#x27;</span>);alert(<span class="hljs-string">&quot;哈哈哈哈哈&quot;</span>);<span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;┭┮﹏┭┮&quot;</span>);&#125;    fun2();<span class="hljs-comment">//调用fun2</span></code></pre></li><li>使用<strong>函数表达式</strong>来创建一个函数  <blockquote><p>语法：var 函数名 = function([形参1，形参2…形参N]) {<br>语句…;语句…;<br>}</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fun3 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是匿名函数中的封装函数&quot;</span>);&#125;fun3();</code></pre></li></ul><h2 id="2-函数的参数"><a href="#2-函数的参数" class="headerlink" title="2.函数的参数"></a>2.函数的参数</h2><ul><li>定义一个求两数之和的函数  <pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a,b</span>) </span>&#123;<span class="hljs-comment">//a和b即为形参，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值</span><span class="hljs-built_in">console</span>.log(a + b);&#125;sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//1和2即为调用的实参，会赋值给对应的形参</span><span class="hljs-comment">/* </span><span class="hljs-comment">调用函数时，解析器不会检查实参的类型；</span><span class="hljs-comment">调用函数时，解析器也不会检查实参的数量</span><span class="hljs-comment">    多余的实参不会被赋值；</span><span class="hljs-comment">      实参的数量少于形参的数量，则没有对应实参的形参将会是undefined</span><span class="hljs-comment"> */</span></code></pre></li></ul><h2 id="3-return-返回值"><a href="#3-return-返回值" class="headerlink" title="3.return 返回值"></a>3.return 返回值</h2><ul><li>创建一个函数，用来计算三个数的和  <pre><code class="hljs javascript"><span class="hljs-comment">/*</span><span class="hljs-comment">可以使用 return 来设置函数返回值</span><span class="hljs-comment">语法：return 值;</span><span class="hljs-comment">return后的值将会作为函数的执行结果返回，可以定义一个变量来接收结果</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a,b,c</span>) </span>&#123;d = a + b + c;<span class="hljs-keyword">return</span> d;alert(<span class="hljs-string">&quot;你好&quot;</span>);  <span class="hljs-comment">//在函数中，return后的语句都不会执行</span>&#125;<span class="hljs-comment">//变量result接收函数的执行结果</span><span class="hljs-comment">//函数返回什么，result的值就是什么</span><span class="hljs-keyword">var</span> result = sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;result = &quot;</span>+result);</code></pre><blockquote><p><code>break;</code>  //退出当前循环<br><code>continue;</code>   //跳过当次循环<br><code>return;</code> //结束整个函数<br>返回值可以是任意类型，可以是对象也可以是函数。  </p></blockquote></li></ul><h2 id="4-立即执行函数"><a href="#4-立即执行函数" class="headerlink" title="4.立即执行函数"></a>4.立即执行函数</h2><blockquote><p>函数定义完，立即被调用，只执行一次  </p></blockquote><pre><code class="hljs clojure">(<span class="hljs-name">function</span>()&#123;alert(<span class="hljs-string">&quot;我是一个匿名函数&quot;</span>)<span class="hljs-comment">;</span>&#125;)()<span class="hljs-comment">;</span>(<span class="hljs-name">function</span>(<span class="hljs-name">a</span>,b)&#123;console.log(<span class="hljs-string">&quot;a = &quot;</span>+a)<span class="hljs-comment">;</span>console.log(<span class="hljs-string">&quot;b = &quot;</span>+b)<span class="hljs-comment">;</span>&#125;)(<span class="hljs-number">123</span>,<span class="hljs-number">456</span>)<span class="hljs-comment">;</span></code></pre><h2 id="5-对象"><a href="#5-对象" class="headerlink" title="5.对象"></a>5.对象</h2><ul><li>方法  <blockquote><p>函数也可以成为对象的属性，如果一个函数作为一个对象的函数保存，则我们称这个函数为这个对象的方法；<br>调用这个函数就说调用对象的方法(method)，但是他只是名称上的区别，没有其他的区别。  </p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-comment">//创建一个新的对象</span>name:<span class="hljs-string">&quot;卡卡罗特&quot;</span>,age:<span class="hljs-number">18</span>,sayName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//对象中的属性值可以是任何的数据类型，也可以是个函数</span><span class="hljs-built_in">console</span>.log(obj.name);&#125;&#125;;obj.sayName();  <span class="hljs-comment">//调用方法</span></code></pre></li></ul><h2 id="6-枚举对象的属性"><a href="#6-枚举对象的属性" class="headerlink" title="6.枚举对象的属性"></a>6.枚举对象的属性</h2><blockquote><p>使用 for…in 语句<br>语法：<br>for(var 变量 in 对象) {<br>}  </p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> n <span class="hljs-keyword">in</span> obj) &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;属性名：&quot;</span>+n);<span class="hljs-comment">//输出属性名</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;属性值：&quot;</span>+obj[n]);<span class="hljs-comment">//输出属性值</span>&#125;</code></pre><h2 id="7-作用域-Scope"><a href="#7-作用域-Scope" class="headerlink" title="7.作用域(Scope)"></a>7.作用域(Scope)</h2><p>指一个变量的作用范围  </p><ul><li><p>全局作用域</p><blockquote><ul><li>直接编写在script标签中的JS代码，都在全局作用域中。</li><li>在页面打开时创建，页面关闭时销毁。</li><li>在全局作用域中，有一个全局对象window(代表一个浏览器窗口，由浏览器创建，可以直接使用)，我们可以直接使用。</li><li>在全局作用域中:<br>创建的变量都会作为window对象的属性保存;<br>创建的函数都会作为window的函数保存。 </li><li>全局作用域中的变量都是全局变量，在页面中任意部分都可以访问得到  </li></ul></blockquote><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是fun&quot;</span>);&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.fun);<span class="hljs-comment">//作为window函数保存</span></code></pre></li><li><p>提前声明  </p><blockquote><p>变量的声明提前：<br> 使用var关键字声明的变量，会在所有的代码执行之前被声明(但是不会赋值)；<br> 但是如果声明变量时，不使用var关键字，则变量不会被声明提前。  </p></blockquote><blockquote><p>函数的声明提前：<br> 使用函数声明形式创建的函数 function 函数(){}，它会在所有的代码执行之前就被创建，所以我们可以在函数声明前调用函数；<br> 使用函数表达式创建的函数不会被声明提前，所以不能在声明前调用。</p></blockquote></li><li><p>函数作用域  </p><blockquote><ul><li>调用函数时创建函数作用域，函数执行完毕之后，函数作用域销毁；</li><li>每调用一次函数就会创建一次新的函数作用域，他们之间是相互独立的；</li><li>在函数作用域中可以访问到全局变量,在全局作用域中无法访问函数作用域的变量；</li><li>当在函数作用域中操作一个变量时，先会在自身作用域中寻找，如果有就直接使用，如果没有就向上级作用域中寻找，直到找到全局作用域，如果全局作用域也未找到，则会报错BeferenceError；</li><li>在函数中要访问全局变量，可以使用window对象。  </li></ul></blockquote><pre><code class="hljs javascript"><span class="hljs-comment">//函数作用域中，var关键字声明的变量，会在函数中所有代码执行前声明</span><span class="hljs-comment">//函数声明也会在函数中所有代码执行前建立</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun3</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//a已经声明，未赋值，会输出undefined</span>fun4(); <span class="hljs-comment">//已建立</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">35</span>;<span class="hljs-comment">//赋值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun4</span>(<span class="hljs-params"></span>) </span>&#123;alert(<span class="hljs-string">&quot;fun4&quot;</span>);&#125;&#125;fun3();<span class="hljs-keyword">var</span> c = <span class="hljs-number">33</span>;</code></pre><pre><code class="hljs js"><span class="hljs-comment">//在函数中，不使用var声明的变量都会成为全局变量</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun5</span>(<span class="hljs-params"></span>) </span>&#123;d = <span class="hljs-number">100</span>;<span class="hljs-comment">//没有使用var关键字，则会设置为全局变量</span>&#125;fun5();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;d = &quot;</span>+d);<span class="hljs-comment">//在全局输出d,会输出100</span></code></pre><pre><code class="hljs delphi"><span class="hljs-comment">//定义形参就相当于在函数作用域中声明了变量</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun6</span><span class="hljs-params">(e)</span> <span class="hljs-comment">&#123;</span></span><span class="hljs-function"><span class="hljs-comment">alert(e);</span></span><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><span class="hljs-function"><span class="hljs-title">fun6</span><span class="hljs-params">()</span>;</span></code></pre></li></ul><h2 id="8-this"><a href="#8-this" class="headerlink" title="8.this"></a>8.this</h2><p>&emsp;解析器在调用函数时，每次都会向函数内部传递进一个隐含的参数,这个隐含的参数就是this，this指向的是一个对象。这个对象我们称为函数执行的上下文对象，根据函数的调用方式不同，this会指向不同的对象：<br>&emsp;1.以函数的形式调用时，this永远都是window<br>&emsp;2.以方法的形式调用时，this就是调用方法的对象<br>&emsp;3.在构造函数中可以使用this来引用新建的对象  </p><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;全局的name属性&quot;</span>;<span class="hljs-comment">//创建一个函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);&#125;  <span class="hljs-comment">//创建一个对象</span><span class="hljs-keyword">var</span> obj = &#123;name:<span class="hljs-string">&quot;卡卡罗特&quot;</span>,sayName:fun<span class="hljs-comment">//即obj.sayName == fun</span>&#125;;fun();  <span class="hljs-comment">//以函数的形式调用，this是window</span>obj.sayName();  <span class="hljs-comment">//以方法的形式调用，this是调用方法的对象</span></code></pre><h2 id="9-工厂方法创建对象"><a href="#9-工厂方法创建对象" class="headerlink" title="9.工厂方法创建对象"></a>9.工厂方法创建对象</h2><p>&emsp;通过该方法可以大批量创建对象  </p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">creatPerson</span>(<span class="hljs-params">name,age,gender</span>)</span>&#123;<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<span class="hljs-comment">//创建一个新的对象</span><span class="hljs-comment">//向对象中添加属性</span>obj.name = name;obj.age = age;obj.gender = gender;obj.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;alert(<span class="hljs-built_in">this</span>.name);&#125;;<span class="hljs-comment">//将新的对象返回</span><span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-comment">//创建对象及其属性</span><span class="hljs-keyword">var</span> obj2 = creatPerson(<span class="hljs-string">&quot;卡卡罗特&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;赛亚人&quot;</span>);<span class="hljs-keyword">var</span> obj3 = creatPerson(<span class="hljs-string">&quot;贝吉塔&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;赛亚人&quot;</span>);<span class="hljs-keyword">var</span> obj4 = creatPerson(<span class="hljs-string">&quot;比鲁斯&quot;</span>,<span class="hljs-number">100</span>,<span class="hljs-string">&quot;破坏神&quot;</span>);</code></pre><blockquote><p>不足之处：使用工厂方法创建的对象都是Object类型，导致我们无法区分出多种不同类型的对象。(用构造函数解决)</p></blockquote><h2 id="10-构造函数"><a href="#10-构造函数" class="headerlink" title="10.构造函数"></a>10.构造函数</h2><p>&emsp;构造函数就是一个普通函数，创建方式和普通函数没区别，不同的是构造函数习惯上首字母大写。构造函数和普通函数的调用方式不同，普通函数是直接调用，而构造函数需要使用new关键字调用。  </p><p>&emsp;构造函数的执行流程:<br>&emsp;1.立刻创建一个新的对象;<br>&emsp;2.将我们新建的对象设置为设置为函数中的this，在构造函数中可以使用this来引用新建的对象;<br>&emsp;3.逐行执行函数中的代码;<br>&emsp;4.将新建的对象作为返回值返回.</p><blockquote><p>使用同一个构造函数创建的对象，称为同一类对象，也将一个构造函数称为一个类。<br>             我们将通过一个构造函数创建的对象，称为是该类的实例。  </p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age,gender</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;<span class="hljs-built_in">this</span>.age = age;<span class="hljs-built_in">this</span>.gender = gender;<span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;alert(<span class="hljs-built_in">this</span>.name);&#125;;&#125;<span class="hljs-comment">//per1 是 Person 的实例</span><span class="hljs-keyword">var</span> per1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;卡卡罗特&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;赛亚人&quot;</span>);<span class="hljs-keyword">var</span> per2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;贝吉塔&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;赛亚人&quot;</span>);<span class="hljs-keyword">var</span> per3 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;比鲁斯&quot;</span>,<span class="hljs-number">100</span>,<span class="hljs-string">&quot;破坏神&quot;</span>);<span class="hljs-comment">//使用instanceof可以检查一个对象是否是一个类的实例</span><span class="hljs-built_in">console</span>.log(per1 <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//返回true</span><span class="hljs-comment">//所有的对象都是Object的后代,任何对象和Object用instanceof检查时都会返回true</span><span class="hljs-built_in">console</span>.log(per1 <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//返回true</span></code></pre><blockquote><p>上述不足：<br>在Person构造函数中，为每一个对象都添加了一个sayName方法，是在构造函数内部创建的，构造函数每执行一次，都会创建一个新的sayName方法，所有Person的sayName都是唯一的，这样就导致构造函数执行一次就会创建一个新的方法，执行10000次就会创建10000个新的方法，而10000个方法都是一模一样的。(用原型解决)  </p></blockquote><h2 id="11-原型-prototype"><a href="#11-原型-prototype" class="headerlink" title="11.原型 prototype"></a>11.原型 prototype</h2><p>&emsp;我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，这个属性对应一个对象，这个对象就是我们所谓的原型对象；<br>&emsp;当我们的函数作为普通函数调用，prototype没有任何作用；<br>&emsp;当函数作为构造函数调用时，他所创建的对象中，都会有一个隐含的属性，指向该构造函数的原型对象，可以通过__proto__来访问该属性。</p><p>&emsp;原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。  </p><p>&emsp;当访问函数对象的一个属性或者方法时，会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。  </p><p>&emsp;以后创造构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用每一个对象添加，也不会影响到全局作用域就可以使每个对象都具有这些属性和方法了。  </p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"></span>) </span>&#123;&#125;MyClass.prototype.a = <span class="hljs-number">123</span>;<span class="hljs-comment">//向MyClass的原型中添加属性a</span>MyClass.prototype.sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//向MyClass的原型中添加一个方法</span>alert(<span class="hljs-string">&quot;你好！！！&quot;</span>);&#125;;<span class="hljs-keyword">var</span> mc = <span class="hljs-keyword">new</span> MyClass();<span class="hljs-built_in">console</span>.log(mc.__proto__);  <span class="hljs-comment">// mc.__proto__ == MyClass.prototype</span><span class="hljs-built_in">console</span>.log(mc.a);<span class="hljs-built_in">console</span>.log(mc.sayHello());</code></pre><blockquote><p>使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true<br>可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性 <code>mc.hasOwnProperty(&quot;name&quot;)</code>  </p></blockquote><blockquote><p>原型对象也是对象，所以它也有原型<br>  &emsp;当我们使用一个对象的属性或者方法时，会先在自身中寻找<br>    &emsp;&emsp;如果自身中有，则直接使用;<br>    &emsp;&emsp;如果没有则去原型对象中寻找，如果原型对象中有则使用;<br>    &emsp;&emsp;如果没有的去原型的原型中寻找，直到找到Object对象的原型;<br>    &emsp;&emsp;Object对象的原型没有原型，如果Object中依然没有找到，则返回undefined。  </p></blockquote><ul><li>toString  <blockquote><p>当直接在页面中打印一个对象时，实际上输出的是对象的toString()方法的返回值<br>如果希望输出对象时不输出[object Object]，可以为对象添加一个toString()方法  </p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//修改Person原型的toString</span>Person.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person[name:&quot;</span>+<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;，age:&quot;</span>+<span class="hljs-built_in">this</span>.age+<span class="hljs-string">&quot;,gender:&quot;</span>+<span class="hljs-built_in">this</span>.gender+<span class="hljs-string">&quot;]&quot;</span>;&#125;</code></pre></li></ul><h2 id="12-垃圾回收-GC"><a href="#12-垃圾回收-GC" class="headerlink" title="12.垃圾回收(GC)"></a>12.垃圾回收(GC)</h2><blockquote><ul><li>就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾，垃圾过多会导致程序运行过慢，所以需要一个垃圾回收的机制，来处理程序运行过程中的垃圾;</li><li>当一个对象没有任何的变量或属性对它进行引用，我们将永远无法操作该对象，这种对象就是一个垃圾，过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理;</li><li>在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作;</li><li>我们需要做的只是将不再使用的对象设置null即可。</li></ul></blockquote><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<span class="hljs-comment">//对对象进行各种操作</span>obj = <span class="hljs-literal">null</span>;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object类型_js</title>
    <link href="/2020/08/28/Object%E7%B1%BB%E5%9E%8B-js/"/>
    <url>/2020/08/28/Object%E7%B1%BB%E5%9E%8B-js/</url>
    
    <content type="html"><![CDATA[<h1 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h1><h2 id="1-对象说明"><a href="#1-对象说明" class="headerlink" title="1.对象说明"></a>1.对象说明</h2><ul><li>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性<br>对象的分类：  <blockquote><p>1.内建对象: 由ES标准中定义的对象，在任何的ES的实现中都可以使用（比如：Math String Number Boolean Function Object）；<br>2.宿主对象: 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象(比如 BOM DOM)；<br>3.自定义对象: 由开发人员自己创建的对象。  </p></blockquote></li></ul><h2 id="2-创建对象"><a href="#2-创建对象" class="headerlink" title="2.创建对象"></a>2.创建对象</h2><ul><li><p>使用new创建： <code>var obj = new Object();</code>  </p></li><li><p>使用对象字面量创建：<code>var obj = &#123;&#125;;</code>  </p><blockquote><p>使用对象字面量，可以在创建对象时，直接指定对象中的属性<br>语法：  </p></blockquote><pre><code>var obj = &#123;    name:&quot;卡卡罗特&quot;,    gender:&quot;男&quot;,    age:99,    &quot;energy&quot;:3000,    //属性名引号可加可不加，建议不加，如需使用特殊名字，则必须加    test:&#123;name:&quot;贝吉塔&quot;&#125;    //最后一个属性不写 ,&#125;;  </code></pre></li></ul><h2 id="3-添加属性"><a href="#3-添加属性" class="headerlink" title="3.添加属性"></a>3.添加属性</h2><ul><li>尽量按照标识符的规范   <pre><code>var obj = new Object();obj.name = &quot;杨涛&quot;;</code></pre></li><li>使用特殊的属性名  <blockquote><p>对象[“属性名”] = 属性值; （ []中可以加变量）<br><code>obj[&quot;123&quot;] = 789;</code>  </p></blockquote></li></ul><h2 id="4-修改与删除属性"><a href="#4-修改与删除属性" class="headerlink" title="4.修改与删除属性"></a>4.修改与删除属性</h2><ul><li>修改属性  <blockquote><p>语法：对象.属性名 = 新值;<br><code>var obj = &#123;name:&quot;卡卡罗特&quot;&#125;;</code><br><code>obj.name = &quot;孙悟空&quot;;</code>  </p></blockquote></li><li>删除属性  <blockquote><p>语法：delete 对象.属性名<br><code>delete obj.name;</code>  </p></blockquote></li></ul><h2 id="5-保存位置"><a href="#5-保存位置" class="headerlink" title="5.保存位置"></a>5.保存位置</h2><blockquote><p><strong>基本数据类型的值直接在 栈内存 中存储</strong>，值与值之间是独立存在的，修改一个变量不会影响其他的变量  </p></blockquote><blockquote><p><strong>对象是保存到 堆内存 中的</strong>，每创建一个新的对象，就会在堆内存中开辟一个新的空间，而变量保存的是对象的内存地址(对象的引用),如果两个变量保存的是同一个对象引用，当一个通过变量修改属性时，另一个变量也会受到影响。</p></blockquote><blockquote><p>当比较两个基本数据类型的值时，就是比较值;<br>而比较两个引用数据类型时，它是比较对象的内存地址;<br>如果两个对象是一模一样，但是地址不同，也会返回false。<br><code>var a = 10, b = 10;    // a == b</code><br><code>obj1.name = &quot;卡卡罗特&quot;;obj2.name = &quot;卡卡罗特&quot;;    // obj1 != obj2</code></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本语法_js</title>
    <link href="/2020/08/25/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-js/"/>
    <url>/2020/08/25/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-js/</url>
    
    <content type="html"><![CDATA[<h1 id="JS基本语法"><a href="#JS基本语法" class="headerlink" title="JS基本语法"></a>JS基本语法</h1><h2 id="1-输入输出"><a href="#1-输入输出" class="headerlink" title="1.输入输出"></a>1.输入输出</h2><ul><li>输入：  <pre><code class="hljs awk">prompt();<span class="hljs-regexp">//</span>字符串输入  +prompt();<span class="hljs-regexp">//</span>数字输入</code></pre></li><li>输出：  <pre><code class="hljs awk">alert();<span class="hljs-regexp">//</span>警告框输出document.write();<span class="hljs-regexp">//</span>body中输出console.log();<span class="hljs-regexp">//</span>控制台输出</code></pre></li></ul><h2 id="2-数据类型与转换"><a href="#2-数据类型与转换" class="headerlink" title="2.数据类型与转换"></a>2.数据类型与转换</h2><p>可以通过<code>typeof + 变量名</code>检查变量的数据类型</p><ul><li>String 字符串  <table><thead><tr><th align="left">说明</th><th align="left">用单引号或双引号引起来，但不能混用，不能同一嵌套</th></tr></thead><tbody><tr><td align="left">特殊符号</td><td align="left">&quot; = “</td></tr><tr><td align="left"></td><td align="left">&#39; = ‘</td></tr><tr><td align="left"></td><td align="left">\n = 换行</td></tr><tr><td align="left"></td><td align="left">\t = 制表符</td></tr><tr><td align="left"></td><td align="left">\ = \</td></tr><tr><td align="left">强制类型转换</td><td align="left">toString()方法：<code>a = a.toString();</code></td></tr><tr><td align="left"></td><td align="left">String()函数：<code>a = String(a);</code></td></tr></tbody></table></li></ul><ul><li><p>Number 数值  </p><table><thead><tr><th align="left">说明</th><th align="left">js中所有数值都为Number类型，包括整数和浮点数</th></tr></thead><tbody><tr><td align="left">强制类型转换</td><td align="left">Number()函数：<code> a = Number(a);</code></td></tr><tr><td align="left"></td><td align="left">String()函数：<code>a = String(a);</code></td></tr><tr><td align="left"></td><td align="left">parseInt()函数，转为整数：<code>a = parseInt(a);</code></td></tr><tr><td align="left"></td><td align="left">parseFloat()函数，转为整数：<code>a = parseFloat(a);</code></td></tr><tr><td align="left"></td><td align="left">true = 1, false = 0, Null = 0，undefined = NaN</td></tr><tr><td align="left">其他进制</td><td align="left">以0x开头表示16进制数字</td></tr><tr><td align="left"></td><td align="left">以0开头为8进制数字</td></tr></tbody></table></li><li><p>Boolean 布尔值  </p><table><thead><tr><th align="left">说明</th><th align="left">布尔值表示逻辑判断,true 表示真,false 表示假</th></tr></thead><tbody><tr><td align="left">Boolean()函数类型转换</td><td align="left">Number 除了 0 和 NaN ，其他都为true</td></tr><tr><td align="left"></td><td align="left">String 除了空串，其他都是true</td></tr><tr><td align="left"></td><td align="left">Null 和 Undefined 都是false</td></tr><tr><td align="left"></td><td align="left">Object 转换为true</td></tr></tbody></table></li><li><p>Null 空值  </p><blockquote><p>Null类型的值就只有一个，就是null,表示第一个空对象,typeof检查null时，会返回object</p></blockquote></li><li><p>Undefined 未定义</p><blockquote><p>Undefined(未定义) 类型的值只有一个，就是undefind,当声明一个变量，但并不给变量赋值是，它的值就是undefined,typeof检查undefined，会返回undefined</p></blockquote></li><li><p>Object 对象  </p></li></ul><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3.运算符"></a>3.运算符</h2><ul><li><p>一元运算符  </p><blockquote><p>自增：自身基础上增加1 ,自增后，值立即自增1,分为两种：a++ 和 ++a</p><pre><code>  var a = 1;  a++ = 1;  ++a = 2;    //a++ 和 ++a 的值不同  a = 2;  </code></pre><p>自减同上</p></blockquote></li><li><p>逻辑运算符  </p><ul><li><p>!非：  </p><blockquote><p>一个值进行非运算 对一个布尔值进行取反操作，true –&gt; flase</p></blockquote></li><li><p>&amp;&amp;与：  </p><blockquote><p> &amp;&amp;与：可以对符号两侧的值进行与运算；<br>只有两端的值都为true时，才会返回true。只要有一个false就会返回false；<br>与是一个短路的与，如果第一个值是false，则不再检查第二个值；<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值；<br>规则：<br>1.第一个值为false，则返回第一个值；<br>2.如果第一个值为true，则返回第二个值。 </p></blockquote></li><li><p>||或：  </p><blockquote><p> 可以对符号两侧的值进行或运算；<br>只有两端都是false时，才会返回false。只要有一个true，就会返回true；<br>或是一个短路的或，如果第一个值是true，则不再检查第二个值；<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值；<br>规则：<br>1.如果第一个值为true，则返回第一个值；<br>2.如果第一个值为false，则返回第二个值。  </p></blockquote></li></ul></li><li><p>赋值运算符  </p><table><thead><tr><th align="left">赋值运算符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">可以将符号右侧的值赋值给左侧变量</td></tr><tr><td align="left">+=</td><td align="left">a += 5; 相当于 a = a+5; 可连接字符串</td></tr><tr><td align="left">-=</td><td align="left">a -= 5  相当于 a = a-5</td></tr><tr><td align="left">其他类似</td><td align="left">……</td></tr></tbody></table></li><li><p>关系运算符  </p><table><thead><tr><th align="left"></th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">符号</td><td align="left">&gt; &lt; &gt;= &lt;=</td></tr><tr><td align="left"></td><td align="left">比较两个值之间的关系，如果关系成立则返回true，关系不成立则返回false。</td></tr><tr><td align="left"></td><td align="left">如果比较的两个值是非数值，会将其转换为Number然后再比较。</td></tr><tr><td align="left"></td><td align="left">如果比较的两个值都是字符串，此时会比较字符串的Unicode编码，而不会转换为Number。</td></tr></tbody></table></li><li><p>相等运算符  </p><table><thead><tr><th align="left">符号</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false (相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，转换后相等它也会返回true。)</td></tr><tr><td align="left">!=</td><td align="left">不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false (不等也会做自动的类型转换。)</td></tr><tr><td align="left">===</td><td align="left">全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换 (如果两个值的类型不同，则直接返回false)</td></tr><tr><td align="left">!==</td><td align="left">不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true</td></tr><tr><td align="left">特殊的值</td><td align="left">由于undefined衍生自null，所以null == undefined 会返回true。但是 null === undefined 会返回false。</td></tr><tr><td align="left"></td><td align="left">NaN不与任何值相等，报告它自身 NaN == NaN 返回false</td></tr><tr><td align="left"></td><td align="left">判断一个值是否是NaN，使用isNaN()函数</td></tr></tbody></table></li><li><p>三元运算符 ?  </p><blockquote><p>语法：条件表达式?语句1:语句2;<br>  执行流程：</p><blockquote><p>先对条件表达式求值判断;<br>   如果判断结果为true，则执行语句1，并返回执行结果<br>   如果判断结果为false，则执行语句2，并返回执行结果  </p></blockquote></blockquote></li><li><p>运算符优先级  </p><blockquote><p>和数学中一样，JS中的运算符也是具有优先级的，比如 先乘除 后加减 先与 后或;<br>  具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高，<br>  优先级越高的越优先计算，优先级相同的，从左往右计算。<br>  优先级不需要记忆，如果越到拿不准的，使用()来改变优先级。  </p></blockquote></li></ul><h2 id="4-流程控制语句"><a href="#4-流程控制语句" class="headerlink" title="4.流程控制语句"></a>4.流程控制语句</h2><p>程序都是自上向下的顺序执行的，通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。  </p><ul><li>if（条件判断语句） <pre><code class="hljs lasso"><span class="hljs-keyword">if</span>(条件表达式)&#123;      语句<span class="hljs-params">...</span>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式)&#123;      语句<span class="hljs-params">...</span>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式)&#123;      语句<span class="hljs-params">...</span>  &#125;<span class="hljs-keyword">else</span>&#123;      语句<span class="hljs-params">...</span>  &#125;<span class="hljs-comment">//自上到下判断</span></code></pre></li><li>switch（条件分支语句）  <pre><code class="hljs autoit"><span class="hljs-keyword">switch</span>(条件表达式)&#123;      <span class="hljs-keyword">case</span> 表达式:          语句...          <span class="hljs-built_in">break</span><span class="hljs-comment">;</span>      <span class="hljs-keyword">case</span> 表达式:          语句...          <span class="hljs-built_in">break</span><span class="hljs-comment">;</span>      <span class="hljs-keyword">default</span>:          语句...          <span class="hljs-built_in">break</span><span class="hljs-comment">;</span>  &#125;//依次将 <span class="hljs-keyword">case</span>后的表达式的值 和 <span class="hljs-keyword">switch</span>后的表达式的值 进行 全等比较</code></pre></li><li>while 循环  <pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(条件表达式)</span></span>&#123;语句...&#125;<span class="hljs-comment">//先判断再循环</span></code></pre></li><li>do while 循环  <pre><code class="hljs awk"><span class="hljs-keyword">do</span>&#123; 语句...&#125;<span class="hljs-keyword">while</span>(条件表达式)<span class="hljs-regexp">//</span>先判断再循环，至少循环一次</code></pre></li><li>for 循环  <pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(①初始化表达式 ; ②条件表达式 ; ④更新表达式)</span></span>&#123; ③语句...&#125;<span class="hljs-comment">//①--&gt;②--&gt;③--&gt;④</span></code></pre></li><li>break 与 continue  <blockquote><p>break可以用来退出switch或循环语句<br>continue可以跳过当次循环<br>不能再if语句中使用  </p></blockquote></li></ul><h2 id="5-小练习"><a href="#5-小练习" class="headerlink" title="5.小练习"></a>5.小练习</h2><ul><li>水仙花数  <blockquote><p>水仙花数是指一个3位数，它的每个位上的数字的3 次幂之和等于它本身。请打印所有的水仙花数。（例如：1^3 + 5^3 + 3^3 = 153）  </p></blockquote><pre><code class="hljs bash">var i,a,b,c;<span class="hljs-keyword">for</span>(i = 100;i &lt;= 999;i++) &#123;a = parseInt(i/100);//得到百位数ab = parseInt(i%100/10);//得到十位数bc = i%10;//得到个位数c<span class="hljs-keyword">if</span>(i == a*a*a + b*b*b + c*c*c) &#123;document.write(i+<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>);     &#125;&#125;</code></pre></li><li>九九乘法表<pre><code class="hljs matlab">var <span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>;<span class="hljs-keyword">for</span>(<span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>;<span class="hljs-built_in">i</span> &lt;= <span class="hljs-number">9</span>;<span class="hljs-built_in">i</span>++) &#123;<span class="hljs-keyword">for</span>( <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>;<span class="hljs-built_in">j</span> &lt;= <span class="hljs-built_in">i</span>;<span class="hljs-built_in">j</span>++) &#123;document.write(<span class="hljs-built_in">j</span> +<span class="hljs-string">&quot;*&quot;</span>+ <span class="hljs-built_in">i</span> +<span class="hljs-string">&quot;=&quot;</span>+ <span class="hljs-built_in">i</span>*<span class="hljs-built_in">j</span> +<span class="hljs-string">&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;</span>);&#125;document.write(<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>);&#125;</code></pre></li><li>质数  <blockquote><p>打印出1-100间所有的质数</p></blockquote><pre><code>var i,j;for(i = 2;i &lt;= 100;i++) &#123;  var flag = true;  for(j = 2;j &lt;= Math.sqrt(i);j++) &#123;    //j最大值去根号下i      if(i % j == 0) &#123;      flag = false;      break;    //break优化      &#125;  &#125;  if(flag == true) &#123;  document.write(i+&quot;&lt;br/&gt;&quot;);  &#125;&#125;</code></pre></li></ul><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>前面学习的还是太慢了，记录的时候也不知道是详细一些好还是简单一些，就随便记了一下。算是了解一下如何写博客，希望自己能够养成学习的同时记录博客的好习惯。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客_note</title>
    <link href="/2020/08/23/Blog%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2020/08/23/Blog%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-Blog-Tag"><a href="#Hexo-Blog-Tag" class="headerlink" title="Hexo Blog Tag"></a>Hexo Blog Tag</h1><h2 id="关于修改"><a href="#关于修改" class="headerlink" title="关于修改"></a>关于修改</h2><pre><code class="hljs bash">利用VScode打开 E:\1_Web前端\blog\<span class="hljs-built_in">source</span>\_data\fluid_config.yml 进行修改</code></pre><h2 id="关于保存"><a href="#关于保存" class="headerlink" title="关于保存"></a>关于保存</h2><pre><code class="hljs bash">打开Git Bashhexo g    hexo d    hexo s(启动本地服务器)</code></pre><h2 id="本地访问与编辑"><a href="#本地访问与编辑" class="headerlink" title="本地访问与编辑"></a>本地访问与编辑</h2><pre><code class="hljs bash">本地地址：http://localhost:4000在线编辑视窗：http://localhost:4000/admin （本地hexo博客地址 + admin即可）</code></pre><h6 id="相关网址："><a href="#相关网址：" class="headerlink" title="相关网址："></a>相关网址：</h6><p><a href="https://hexo.io/docs/">hexo官方文档</a><br><a href="https://hexo.fluid-dev.com/docs/">fluid用户文档</a><br><a href="https://imgchr.com/">路过图床</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
