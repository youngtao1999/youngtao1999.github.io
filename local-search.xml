<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>函数与对象_js</title>
    <link href="/2020/09/01/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AF%B9%E8%B1%A1-js/"/>
    <url>/2020/09/01/%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AF%B9%E8%B1%A1-js/</url>
    
    <content type="html"><![CDATA[<h1 id="函数与对象"><a href="#函数与对象" class="headerlink" title="函数与对象"></a>函数与对象</h1><p>&emsp;函数 function<br>&emsp;函数也是一个对象<br>&emsp;函数中可以封装一些功能（代码），在需要时可以执行这些功能(代码)<br>&emsp;函数中可以保存一些代码在需要的时候调用<br>&emsp;使用typeof检查一个函数对象时，会返回function  </p><h2 id="1-创建函数"><a href="#1-创建函数" class="headerlink" title="1.创建函数"></a>1.创建函数</h2><ul><li>使用<strong>构造函数</strong>创建  <blockquote><p>实际开发中很少使用构造函数来创建一个函数对象  </p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> = new <span class="hljs-title">Function</span><span class="hljs-params">(<span class="hljs-string">&quot;console.log(&#x27;这是我的第一个函数&#x27;)&quot;</span>)</span></span>;<span class="hljs-comment">//可以将要封装的代码以字符串的形式传递给构造函数</span><span class="hljs-comment">//封装到函数中的代码不会立即执行</span><span class="hljs-comment">//函数中的代码会在函数调用的时候执行</span><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//调用fun</span></code></pre></li><li>使用<strong>函数声明</strong>来创建一个函数  <blockquote><p>语法：function 函数名([形参1，形参2…形参N]) {<br>语句…;语句…;<br>}  </p></blockquote><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun2</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是我的第二个函数&#x27;</span>);alert(<span class="hljs-string">&quot;哈哈哈哈哈&quot;</span>);<span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;┭┮﹏┭┮&quot;</span>);&#125;    fun2();<span class="hljs-comment">//调用fun2</span></code></pre></li><li>使用<strong>函数表达式</strong>来创建一个函数  <blockquote><p>语法：var 函数名 = function([形参1，形参2…形参N]) {<br>语句…;语句…;<br>}</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fun3 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是匿名函数中的封装函数&quot;</span>);&#125;fun3();</code></pre></li></ul><h2 id="2-函数的参数"><a href="#2-函数的参数" class="headerlink" title="2.函数的参数"></a>2.函数的参数</h2><ul><li>定义一个求两数之和的函数  <pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a,b</span>) </span>&#123;<span class="hljs-comment">//a和b即为形参，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值</span><span class="hljs-built_in">console</span>.log(a + b);&#125;sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//1和2即为调用的实参，会赋值给对应的形参</span><span class="hljs-comment">/* </span><span class="hljs-comment">调用函数时，解析器不会检查实参的类型；</span><span class="hljs-comment">调用函数时，解析器也不会检查实参的数量</span><span class="hljs-comment">    多余的实参不会被赋值；</span><span class="hljs-comment">      实参的数量少于形参的数量，则没有对应实参的形参将会是undefined</span><span class="hljs-comment"> */</span></code></pre></li></ul><h2 id="3-return-返回值"><a href="#3-return-返回值" class="headerlink" title="3.return 返回值"></a>3.return 返回值</h2><ul><li>创建一个函数，用来计算三个数的和  <pre><code class="hljs javascript"><span class="hljs-comment">/*</span><span class="hljs-comment">可以使用 return 来设置函数返回值</span><span class="hljs-comment">语法：return 值;</span><span class="hljs-comment">return后的值将会作为函数的执行结果返回，可以定义一个变量来接收结果</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a,b,c</span>) </span>&#123;d = a + b + c;<span class="hljs-keyword">return</span> d;alert(<span class="hljs-string">&quot;你好&quot;</span>);  <span class="hljs-comment">//在函数中，return后的语句都不会执行</span>&#125;<span class="hljs-comment">//变量result接收函数的执行结果</span><span class="hljs-comment">//函数返回什么，result的值就是什么</span><span class="hljs-keyword">var</span> result = sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;result = &quot;</span>+result);</code></pre><blockquote><p><code>break;</code>  //退出当前循环<br><code>continue;</code>   //跳过当次循环<br><code>return;</code> //结束整个函数<br>返回值可以是任意类型，可以是对象也可以是函数。  </p></blockquote></li></ul><h2 id="4-立即执行函数"><a href="#4-立即执行函数" class="headerlink" title="4.立即执行函数"></a>4.立即执行函数</h2><blockquote><p>函数定义完，立即被调用，只执行一次  </p></blockquote><pre><code class="hljs clojure">(<span class="hljs-name">function</span>()&#123;alert(<span class="hljs-string">&quot;我是一个匿名函数&quot;</span>)<span class="hljs-comment">;</span>&#125;)()<span class="hljs-comment">;</span>(<span class="hljs-name">function</span>(<span class="hljs-name">a</span>,b)&#123;console.log(<span class="hljs-string">&quot;a = &quot;</span>+a)<span class="hljs-comment">;</span>console.log(<span class="hljs-string">&quot;b = &quot;</span>+b)<span class="hljs-comment">;</span>&#125;)(<span class="hljs-number">123</span>,<span class="hljs-number">456</span>)<span class="hljs-comment">;</span></code></pre><h2 id="5-对象"><a href="#5-对象" class="headerlink" title="5.对象"></a>5.对象</h2><ul><li>方法  <blockquote><p>函数也可以成为对象的属性，如果一个函数作为一个对象的函数保存，则我们称这个函数为这个对象的方法；<br>调用这个函数就说调用对象的方法(method)，但是他只是名称上的区别，没有其他的区别。  </p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-comment">//创建一个新的对象</span>name:<span class="hljs-string">&quot;卡卡罗特&quot;</span>,age:<span class="hljs-number">18</span>,sayName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//对象中的属性值可以是任何的数据类型，也可以是个函数</span><span class="hljs-built_in">console</span>.log(obj.name);&#125;&#125;;obj.sayName();  <span class="hljs-comment">//调用方法</span></code></pre></li></ul><h2 id="6-枚举对象的属性"><a href="#6-枚举对象的属性" class="headerlink" title="6.枚举对象的属性"></a>6.枚举对象的属性</h2><blockquote><p>使用 for…in 语句<br>语法：<br>for(var 变量 in 对象) {<br>}  </p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> n <span class="hljs-keyword">in</span> obj) &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;属性名：&quot;</span>+n);<span class="hljs-comment">//输出属性名</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;属性值：&quot;</span>+obj[n]);<span class="hljs-comment">//输出属性值</span>&#125;</code></pre><h2 id="7-作用域-Scope"><a href="#7-作用域-Scope" class="headerlink" title="7.作用域(Scope)"></a>7.作用域(Scope)</h2><p>指一个变量的作用范围  </p><ul><li><p>全局作用域</p><blockquote><ul><li>直接编写在script标签中的JS代码，都在全局作用域中。</li><li>在页面打开时创建，页面关闭时销毁。</li><li>在全局作用域中，有一个全局对象window(代表一个浏览器窗口，由浏览器创建，可以直接使用)，我们可以直接使用。</li><li>在全局作用域中:<br>创建的变量都会作为window对象的属性保存;<br>创建的函数都会作为window的函数保存。 </li><li>全局作用域中的变量都是全局变量，在页面中任意部分都可以访问得到  </li></ul></blockquote><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是fun&quot;</span>);&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.fun);<span class="hljs-comment">//作为window函数保存</span></code></pre></li><li><p>提前声明  </p><blockquote><p>变量的声明提前：<br> 使用var关键字声明的变量，会在所有的代码执行之前被声明(但是不会赋值)；<br> 但是如果声明变量时，不使用var关键字，则变量不会被声明提前。  </p></blockquote><blockquote><p>函数的声明提前：<br> 使用函数声明形式创建的函数 function 函数(){}，它会在所有的代码执行之前就被创建，所以我们可以在函数声明前调用函数；<br> 使用函数表达式创建的函数不会被声明提前，所以不能在声明前调用。</p></blockquote></li><li><p>函数作用域  </p><blockquote><ul><li>调用函数时创建函数作用域，函数执行完毕之后，函数作用域销毁；</li><li>每调用一次函数就会创建一次新的函数作用域，他们之间是相互独立的；</li><li>在函数作用域中可以访问到全局变量,在全局作用域中无法访问函数作用域的变量；</li><li>当在函数作用域中操作一个变量时，先会在自身作用域中寻找，如果有就直接使用，如果没有就向上级作用域中寻找，直到找到全局作用域，如果全局作用域也未找到，则会报错BeferenceError；</li><li>在函数中要访问全局变量，可以使用window对象。  </li></ul></blockquote><pre><code class="hljs javascript"><span class="hljs-comment">//函数作用域中，var关键字声明的变量，会在函数中所有代码执行前声明</span><span class="hljs-comment">//函数声明也会在函数中所有代码执行前建立</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun3</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//a已经声明，未赋值，会输出undefined</span>fun4(); <span class="hljs-comment">//已建立</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">35</span>;<span class="hljs-comment">//赋值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun4</span>(<span class="hljs-params"></span>) </span>&#123;alert(<span class="hljs-string">&quot;fun4&quot;</span>);&#125;&#125;fun3();<span class="hljs-keyword">var</span> c = <span class="hljs-number">33</span>;</code></pre><pre><code class="hljs js"><span class="hljs-comment">//在函数中，不使用var声明的变量都会成为全局变量</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun5</span>(<span class="hljs-params"></span>) </span>&#123;d = <span class="hljs-number">100</span>;<span class="hljs-comment">//没有使用var关键字，则会设置为全局变量</span>&#125;fun5();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;d = &quot;</span>+d);<span class="hljs-comment">//在全局输出d,会输出100</span></code></pre><pre><code class="hljs delphi"><span class="hljs-comment">//定义形参就相当于在函数作用域中声明了变量</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun6</span><span class="hljs-params">(e)</span> <span class="hljs-comment">&#123;</span></span><span class="hljs-function"><span class="hljs-comment">alert(e);</span></span><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><span class="hljs-function"><span class="hljs-title">fun6</span><span class="hljs-params">()</span>;</span></code></pre></li></ul><h2 id="8-this"><a href="#8-this" class="headerlink" title="8.this"></a>8.this</h2><p>&emsp;解析器在调用函数时，每次都会向函数内部传递进一个隐含的参数,这个隐含的参数就是this，this指向的是一个对象。这个对象我们称为函数执行的上下文对象，根据函数的调用方式不同，this会指向不同的对象：<br>&emsp;1.以函数的形式调用时，this永远都是window<br>&emsp;2.以方法的形式调用时，this就是调用方法的对象<br>&emsp;3.在构造函数中可以使用this来引用新建的对象  </p><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;全局的name属性&quot;</span>;<span class="hljs-comment">//创建一个函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);&#125;  <span class="hljs-comment">//创建一个对象</span><span class="hljs-keyword">var</span> obj = &#123;name:<span class="hljs-string">&quot;卡卡罗特&quot;</span>,sayName:fun<span class="hljs-comment">//即obj.sayName == fun</span>&#125;;fun();  <span class="hljs-comment">//以函数的形式调用，this是window</span>obj.sayName();  <span class="hljs-comment">//以方法的形式调用，this是调用方法的对象</span></code></pre><h2 id="9-工厂方法创建对象"><a href="#9-工厂方法创建对象" class="headerlink" title="9.工厂方法创建对象"></a>9.工厂方法创建对象</h2><p>&emsp;通过该方法可以大批量创建对象  </p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">creatPerson</span>(<span class="hljs-params">name,age,gender</span>)</span>&#123;<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<span class="hljs-comment">//创建一个新的对象</span><span class="hljs-comment">//向对象中添加属性</span>obj.name = name;obj.age = age;obj.gender = gender;obj.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;alert(<span class="hljs-built_in">this</span>.name);&#125;;<span class="hljs-comment">//将新的对象返回</span><span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-comment">//创建对象及其属性</span><span class="hljs-keyword">var</span> obj2 = creatPerson(<span class="hljs-string">&quot;卡卡罗特&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;赛亚人&quot;</span>);<span class="hljs-keyword">var</span> obj3 = creatPerson(<span class="hljs-string">&quot;贝吉塔&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;赛亚人&quot;</span>);<span class="hljs-keyword">var</span> obj4 = creatPerson(<span class="hljs-string">&quot;比鲁斯&quot;</span>,<span class="hljs-number">100</span>,<span class="hljs-string">&quot;破坏神&quot;</span>);</code></pre><blockquote><p>不足之处：使用工厂方法创建的对象都是Object类型，导致我们无法区分出多种不同类型的对象。(用构造函数解决)</p></blockquote><h2 id="10-构造函数"><a href="#10-构造函数" class="headerlink" title="10.构造函数"></a>10.构造函数</h2><p>&emsp;构造函数就是一个普通函数，创建方式和普通函数没区别，不同的是构造函数习惯上首字母大写。构造函数和普通函数的调用方式不同，普通函数是直接调用，而构造函数需要使用new关键字调用。  </p><p>&emsp;构造函数的执行流程:<br>&emsp;1.立刻创建一个新的对象;<br>&emsp;2.将我们新建的对象设置为设置为函数中的this，在构造函数中可以使用this来引用新建的对象;<br>&emsp;3.逐行执行函数中的代码;<br>&emsp;4.将新建的对象作为返回值返回.</p><blockquote><p>使用同一个构造函数创建的对象，称为同一类对象，也将一个构造函数称为一个类。<br>             我们将通过一个构造函数创建的对象，称为是该类的实例。  </p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age,gender</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;<span class="hljs-built_in">this</span>.age = age;<span class="hljs-built_in">this</span>.gender = gender;<span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;alert(<span class="hljs-built_in">this</span>.name);&#125;;&#125;<span class="hljs-comment">//per1 是 Person 的实例</span><span class="hljs-keyword">var</span> per1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;卡卡罗特&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;赛亚人&quot;</span>);<span class="hljs-keyword">var</span> per2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;贝吉塔&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;赛亚人&quot;</span>);<span class="hljs-keyword">var</span> per3 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;比鲁斯&quot;</span>,<span class="hljs-number">100</span>,<span class="hljs-string">&quot;破坏神&quot;</span>);<span class="hljs-comment">//使用instanceof可以检查一个对象是否是一个类的实例</span><span class="hljs-built_in">console</span>.log(per1 <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//返回true</span><span class="hljs-comment">//所有的对象都是Object的后代,任何对象和Object用instanceof检查时都会返回true</span><span class="hljs-built_in">console</span>.log(per1 <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//返回true</span></code></pre><blockquote><p>上述不足：<br>在Person构造函数中，为每一个对象都添加了一个sayName方法，是在构造函数内部创建的，构造函数每执行一次，都会创建一个新的sayName方法，所有Person的sayName都是唯一的，这样就导致构造函数执行一次就会创建一个新的方法，执行10000次就会创建10000个新的方法，而10000个方法都是一模一样的。(用原型解决)  </p></blockquote><h2 id="11-原型-prototype"><a href="#11-原型-prototype" class="headerlink" title="11.原型 prototype"></a>11.原型 prototype</h2><p>&emsp;我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，这个属性对应一个对象，这个对象就是我们所谓的原型对象；<br>&emsp;当我们的函数作为普通函数调用，prototype没有任何作用；<br>&emsp;当函数作为构造函数调用时，他所创建的对象中，都会有一个隐含的属性，指向该构造函数的原型对象，可以通过__proto__来访问该属性。</p><p>&emsp;原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。  </p><p>&emsp;当访问函数对象的一个属性或者方法时，会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。  </p><p>&emsp;以后创造构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用每一个对象添加，也不会影响到全局作用域就可以使每个对象都具有这些属性和方法了。  </p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"></span>) </span>&#123;&#125;MyClass.prototype.a = <span class="hljs-number">123</span>;<span class="hljs-comment">//向MyClass的原型中添加属性a</span>MyClass.prototype.sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//向MyClass的原型中添加一个方法</span>alert(<span class="hljs-string">&quot;你好！！！&quot;</span>);&#125;;<span class="hljs-keyword">var</span> mc = <span class="hljs-keyword">new</span> MyClass();<span class="hljs-built_in">console</span>.log(mc.__proto__);  <span class="hljs-comment">// mc.__proto__ == MyClass.prototype</span><span class="hljs-built_in">console</span>.log(mc.a);<span class="hljs-built_in">console</span>.log(mc.sayHello());</code></pre><blockquote><p>使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true<br>可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性 <code>mc.hasOwnProperty(&quot;name&quot;)</code>  </p></blockquote><blockquote><p>原型对象也是对象，所以它也有原型<br>  &emsp;当我们使用一个对象的属性或者方法时，会先在自身中寻找<br>    &emsp;&emsp;如果自身中有，则直接使用;<br>    &emsp;&emsp;如果没有则去原型对象中寻找，如果原型对象中有则使用;<br>    &emsp;&emsp;如果没有的去原型的原型中寻找，直到找到Object对象的原型;<br>    &emsp;&emsp;Object对象的原型没有原型，如果Object中依然没有找到，则返回undefined。  </p></blockquote><ul><li>toString  <blockquote><p>当直接在页面中打印一个对象时，实际上输出的是对象的toString()方法的返回值<br>如果希望输出对象时不输出[object Object]，可以为对象添加一个toString()方法  </p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//修改Person原型的toString</span>Person.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person[name:&quot;</span>+<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;，age:&quot;</span>+<span class="hljs-built_in">this</span>.age+<span class="hljs-string">&quot;,gender:&quot;</span>+<span class="hljs-built_in">this</span>.gender+<span class="hljs-string">&quot;]&quot;</span>;&#125;</code></pre></li></ul><h2 id="12-垃圾回收-GC"><a href="#12-垃圾回收-GC" class="headerlink" title="12.垃圾回收(GC)"></a>12.垃圾回收(GC)</h2><blockquote><ul><li>就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾，垃圾过多会导致程序运行过慢，所以需要一个垃圾回收的机制，来处理程序运行过程中的垃圾;</li><li>当一个对象没有任何的变量或属性对它进行引用，我们将永远无法操作该对象，这种对象就是一个垃圾，过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理;</li><li>在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作;</li><li>我们需要做的只是将不再使用的对象设置null即可。</li></ul></blockquote><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<span class="hljs-comment">//对对象进行各种操作</span>obj = <span class="hljs-literal">null</span>;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object类型_js</title>
    <link href="/2020/08/28/Object%E7%B1%BB%E5%9E%8B-js/"/>
    <url>/2020/08/28/Object%E7%B1%BB%E5%9E%8B-js/</url>
    
    <content type="html"><![CDATA[<h1 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h1><h2 id="1-对象说明"><a href="#1-对象说明" class="headerlink" title="1.对象说明"></a>1.对象说明</h2><ul><li>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性<br>对象的分类：  <blockquote><p>1.内建对象: 由ES标准中定义的对象，在任何的ES的实现中都可以使用（比如：Math String Number Boolean Function Object）；<br>2.宿主对象: 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象(比如 BOM DOM)；<br>3.自定义对象: 由开发人员自己创建的对象。  </p></blockquote></li></ul><h2 id="2-创建对象"><a href="#2-创建对象" class="headerlink" title="2.创建对象"></a>2.创建对象</h2><ul><li><p>使用new创建： <code>var obj = new Object();</code>  </p></li><li><p>使用对象字面量创建：<code>var obj = &#123;&#125;;</code>  </p><blockquote><p>使用对象字面量，可以在创建对象时，直接指定对象中的属性<br>语法：  </p></blockquote><pre><code>var obj = &#123;    name:&quot;卡卡罗特&quot;,    gender:&quot;男&quot;,    age:99,    &quot;energy&quot;:3000,    //属性名引号可加可不加，建议不加，如需使用特殊名字，则必须加    test:&#123;name:&quot;贝吉塔&quot;&#125;    //最后一个属性不写 ,&#125;;  </code></pre></li></ul><h2 id="3-添加属性"><a href="#3-添加属性" class="headerlink" title="3.添加属性"></a>3.添加属性</h2><ul><li>尽量按照标识符的规范   <pre><code>var obj = new Object();obj.name = &quot;杨涛&quot;;</code></pre></li><li>使用特殊的属性名  <blockquote><p>对象[“属性名”] = 属性值; （ []中可以加变量）<br><code>obj[&quot;123&quot;] = 789;</code>  </p></blockquote></li></ul><h2 id="4-修改与删除属性"><a href="#4-修改与删除属性" class="headerlink" title="4.修改与删除属性"></a>4.修改与删除属性</h2><ul><li>修改属性  <blockquote><p>语法：对象.属性名 = 新值;<br><code>var obj = &#123;name:&quot;卡卡罗特&quot;&#125;;</code><br><code>obj.name = &quot;孙悟空&quot;;</code>  </p></blockquote></li><li>删除属性  <blockquote><p>语法：delete 对象.属性名<br><code>delete obj.name;</code>  </p></blockquote></li></ul><h2 id="5-保存位置"><a href="#5-保存位置" class="headerlink" title="5.保存位置"></a>5.保存位置</h2><blockquote><p><strong>基本数据类型的值直接在 栈内存 中存储</strong>，值与值之间是独立存在的，修改一个变量不会影响其他的变量  </p></blockquote><blockquote><p><strong>对象是保存到 堆内存 中的</strong>，每创建一个新的对象，就会在堆内存中开辟一个新的空间，而变量保存的是对象的内存地址(对象的引用),如果两个变量保存的是同一个对象引用，当一个通过变量修改属性时，另一个变量也会受到影响。</p></blockquote><blockquote><p>当比较两个基本数据类型的值时，就是比较值;<br>而比较两个引用数据类型时，它是比较对象的内存地址;<br>如果两个对象是一模一样，但是地址不同，也会返回false。<br><code>var a = 10, b = 10;    // a == b</code><br><code>obj1.name = &quot;卡卡罗特&quot;;obj2.name = &quot;卡卡罗特&quot;;    // obj1 != obj2</code></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本语法_js</title>
    <link href="/2020/08/25/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-js/"/>
    <url>/2020/08/25/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-js/</url>
    
    <content type="html"><![CDATA[<h1 id="JS基本语法"><a href="#JS基本语法" class="headerlink" title="JS基本语法"></a>JS基本语法</h1><h2 id="1-输入输出"><a href="#1-输入输出" class="headerlink" title="1.输入输出"></a>1.输入输出</h2><ul><li>输入：  <pre><code class="hljs awk">prompt();<span class="hljs-regexp">//</span>字符串输入  +prompt();<span class="hljs-regexp">//</span>数字输入</code></pre></li><li>输出：  <pre><code class="hljs awk">alert();<span class="hljs-regexp">//</span>警告框输出document.write();<span class="hljs-regexp">//</span>body中输出console.log();<span class="hljs-regexp">//</span>控制台输出</code></pre></li></ul><h2 id="2-数据类型与转换"><a href="#2-数据类型与转换" class="headerlink" title="2.数据类型与转换"></a>2.数据类型与转换</h2><p>可以通过<code>typeof + 变量名</code>检查变量的数据类型</p><ul><li>String 字符串  <table><thead><tr><th align="left">说明</th><th align="left">用单引号或双引号引起来，但不能混用，不能同一嵌套</th></tr></thead><tbody><tr><td align="left">特殊符号</td><td align="left">&quot; = “</td></tr><tr><td align="left"></td><td align="left">&#39; = ‘</td></tr><tr><td align="left"></td><td align="left">\n = 换行</td></tr><tr><td align="left"></td><td align="left">\t = 制表符</td></tr><tr><td align="left"></td><td align="left">\ = \</td></tr><tr><td align="left">强制类型转换</td><td align="left">toString()方法：<code>a = a.toString();</code></td></tr><tr><td align="left"></td><td align="left">String()函数：<code>a = String(a);</code></td></tr></tbody></table></li></ul><ul><li><p>Number 数值  </p><table><thead><tr><th align="left">说明</th><th align="left">js中所有数值都为Number类型，包括整数和浮点数</th></tr></thead><tbody><tr><td align="left">强制类型转换</td><td align="left">Number()函数：<code> a = Number(a);</code></td></tr><tr><td align="left"></td><td align="left">String()函数：<code>a = String(a);</code></td></tr><tr><td align="left"></td><td align="left">parseInt()函数，转为整数：<code>a = parseInt(a);</code></td></tr><tr><td align="left"></td><td align="left">parseFloat()函数，转为整数：<code>a = parseFloat(a);</code></td></tr><tr><td align="left"></td><td align="left">true = 1, false = 0, Null = 0，undefined = NaN</td></tr><tr><td align="left">其他进制</td><td align="left">以0x开头表示16进制数字</td></tr><tr><td align="left"></td><td align="left">以0开头为8进制数字</td></tr></tbody></table></li><li><p>Boolean 布尔值  </p><table><thead><tr><th align="left">说明</th><th align="left">布尔值表示逻辑判断,true 表示真,false 表示假</th></tr></thead><tbody><tr><td align="left">Boolean()函数类型转换</td><td align="left">Number 除了 0 和 NaN ，其他都为true</td></tr><tr><td align="left"></td><td align="left">String 除了空串，其他都是true</td></tr><tr><td align="left"></td><td align="left">Null 和 Undefined 都是false</td></tr><tr><td align="left"></td><td align="left">Object 转换为true</td></tr></tbody></table></li><li><p>Null 空值  </p><blockquote><p>Null类型的值就只有一个，就是null,表示第一个空对象,typeof检查null时，会返回object</p></blockquote></li><li><p>Undefined 未定义</p><blockquote><p>Undefined(未定义) 类型的值只有一个，就是undefind,当声明一个变量，但并不给变量赋值是，它的值就是undefined,typeof检查undefined，会返回undefined</p></blockquote></li><li><p>Object 对象  </p></li></ul><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3.运算符"></a>3.运算符</h2><ul><li><p>一元运算符  </p><blockquote><p>自增：自身基础上增加1 ,自增后，值立即自增1,分为两种：a++ 和 ++a</p><pre><code>  var a = 1;  a++ = 1;  ++a = 2;    //a++ 和 ++a 的值不同  a = 2;  </code></pre><p>自减同上</p></blockquote></li><li><p>逻辑运算符  </p><ul><li><p>!非：  </p><blockquote><p>一个值进行非运算 对一个布尔值进行取反操作，true –&gt; flase</p></blockquote></li><li><p>&amp;&amp;与：  </p><blockquote><p> &amp;&amp;与：可以对符号两侧的值进行与运算；<br>只有两端的值都为true时，才会返回true。只要有一个false就会返回false；<br>与是一个短路的与，如果第一个值是false，则不再检查第二个值；<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值；<br>规则：<br>1.第一个值为false，则返回第一个值；<br>2.如果第一个值为true，则返回第二个值。 </p></blockquote></li><li><p>||或：  </p><blockquote><p> 可以对符号两侧的值进行或运算；<br>只有两端都是false时，才会返回false。只要有一个true，就会返回true；<br>或是一个短路的或，如果第一个值是true，则不再检查第二个值；<br>对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值；<br>规则：<br>1.如果第一个值为true，则返回第一个值；<br>2.如果第一个值为false，则返回第二个值。  </p></blockquote></li></ul></li><li><p>赋值运算符  </p><table><thead><tr><th align="left">赋值运算符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">可以将符号右侧的值赋值给左侧变量</td></tr><tr><td align="left">+=</td><td align="left">a += 5; 相当于 a = a+5; 可连接字符串</td></tr><tr><td align="left">-=</td><td align="left">a -= 5  相当于 a = a-5</td></tr><tr><td align="left">其他类似</td><td align="left">……</td></tr></tbody></table></li><li><p>关系运算符  </p><table><thead><tr><th align="left"></th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">符号</td><td align="left">&gt; &lt; &gt;= &lt;=</td></tr><tr><td align="left"></td><td align="left">比较两个值之间的关系，如果关系成立则返回true，关系不成立则返回false。</td></tr><tr><td align="left"></td><td align="left">如果比较的两个值是非数值，会将其转换为Number然后再比较。</td></tr><tr><td align="left"></td><td align="left">如果比较的两个值都是字符串，此时会比较字符串的Unicode编码，而不会转换为Number。</td></tr></tbody></table></li><li><p>相等运算符  </p><table><thead><tr><th align="left">符号</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false (相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，转换后相等它也会返回true。)</td></tr><tr><td align="left">!=</td><td align="left">不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false (不等也会做自动的类型转换。)</td></tr><tr><td align="left">===</td><td align="left">全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换 (如果两个值的类型不同，则直接返回false)</td></tr><tr><td align="left">!==</td><td align="left">不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true</td></tr><tr><td align="left">特殊的值</td><td align="left">由于undefined衍生自null，所以null == undefined 会返回true。但是 null === undefined 会返回false。</td></tr><tr><td align="left"></td><td align="left">NaN不与任何值相等，报告它自身 NaN == NaN 返回false</td></tr><tr><td align="left"></td><td align="left">判断一个值是否是NaN，使用isNaN()函数</td></tr></tbody></table></li><li><p>三元运算符 ?  </p><blockquote><p>语法：条件表达式?语句1:语句2;<br>  执行流程：</p><blockquote><p>先对条件表达式求值判断;<br>   如果判断结果为true，则执行语句1，并返回执行结果<br>   如果判断结果为false，则执行语句2，并返回执行结果  </p></blockquote></blockquote></li><li><p>运算符优先级  </p><blockquote><p>和数学中一样，JS中的运算符也是具有优先级的，比如 先乘除 后加减 先与 后或;<br>  具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高，<br>  优先级越高的越优先计算，优先级相同的，从左往右计算。<br>  优先级不需要记忆，如果越到拿不准的，使用()来改变优先级。  </p></blockquote></li></ul><h2 id="4-流程控制语句"><a href="#4-流程控制语句" class="headerlink" title="4.流程控制语句"></a>4.流程控制语句</h2><p>程序都是自上向下的顺序执行的，通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。  </p><ul><li>if（条件判断语句） <pre><code class="hljs lasso"><span class="hljs-keyword">if</span>(条件表达式)&#123;      语句<span class="hljs-params">...</span>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式)&#123;      语句<span class="hljs-params">...</span>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式)&#123;      语句<span class="hljs-params">...</span>  &#125;<span class="hljs-keyword">else</span>&#123;      语句<span class="hljs-params">...</span>  &#125;<span class="hljs-comment">//自上到下判断</span></code></pre></li><li>switch（条件分支语句）  <pre><code class="hljs autoit"><span class="hljs-keyword">switch</span>(条件表达式)&#123;      <span class="hljs-keyword">case</span> 表达式:          语句...          <span class="hljs-built_in">break</span><span class="hljs-comment">;</span>      <span class="hljs-keyword">case</span> 表达式:          语句...          <span class="hljs-built_in">break</span><span class="hljs-comment">;</span>      <span class="hljs-keyword">default</span>:          语句...          <span class="hljs-built_in">break</span><span class="hljs-comment">;</span>  &#125;//依次将 <span class="hljs-keyword">case</span>后的表达式的值 和 <span class="hljs-keyword">switch</span>后的表达式的值 进行 全等比较</code></pre></li><li>while 循环  <pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(条件表达式)</span></span>&#123;语句...&#125;<span class="hljs-comment">//先判断再循环</span></code></pre></li><li>do while 循环  <pre><code class="hljs awk"><span class="hljs-keyword">do</span>&#123; 语句...&#125;<span class="hljs-keyword">while</span>(条件表达式)<span class="hljs-regexp">//</span>先判断再循环，至少循环一次</code></pre></li><li>for 循环  <pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(①初始化表达式 ; ②条件表达式 ; ④更新表达式)</span></span>&#123; ③语句...&#125;<span class="hljs-comment">//①--&gt;②--&gt;③--&gt;④</span></code></pre></li><li>break 与 continue  <blockquote><p>break可以用来退出switch或循环语句<br>continue可以跳过当次循环<br>不能再if语句中使用  </p></blockquote></li></ul><h2 id="5-小练习"><a href="#5-小练习" class="headerlink" title="5.小练习"></a>5.小练习</h2><ul><li>水仙花数  <blockquote><p>水仙花数是指一个3位数，它的每个位上的数字的3 次幂之和等于它本身。请打印所有的水仙花数。（例如：1^3 + 5^3 + 3^3 = 153）  </p></blockquote><pre><code class="hljs bash">var i,a,b,c;<span class="hljs-keyword">for</span>(i = 100;i &lt;= 999;i++) &#123;a = parseInt(i/100);//得到百位数ab = parseInt(i%100/10);//得到十位数bc = i%10;//得到个位数c<span class="hljs-keyword">if</span>(i == a*a*a + b*b*b + c*c*c) &#123;document.write(i+<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>);     &#125;&#125;</code></pre></li><li>九九乘法表<pre><code class="hljs matlab">var <span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>;<span class="hljs-keyword">for</span>(<span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>;<span class="hljs-built_in">i</span> &lt;= <span class="hljs-number">9</span>;<span class="hljs-built_in">i</span>++) &#123;<span class="hljs-keyword">for</span>( <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>;<span class="hljs-built_in">j</span> &lt;= <span class="hljs-built_in">i</span>;<span class="hljs-built_in">j</span>++) &#123;document.write(<span class="hljs-built_in">j</span> +<span class="hljs-string">&quot;*&quot;</span>+ <span class="hljs-built_in">i</span> +<span class="hljs-string">&quot;=&quot;</span>+ <span class="hljs-built_in">i</span>*<span class="hljs-built_in">j</span> +<span class="hljs-string">&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;</span>);&#125;document.write(<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>);&#125;</code></pre></li><li>质数  <blockquote><p>打印出1-100间所有的质数</p></blockquote><pre><code>var i,j;for(i = 2;i &lt;= 100;i++) &#123;  var flag = true;  for(j = 2;j &lt;= Math.sqrt(i);j++) &#123;    //j最大值去根号下i      if(i % j == 0) &#123;      flag = false;      break;    //break优化      &#125;  &#125;  if(flag == true) &#123;  document.write(i+&quot;&lt;br/&gt;&quot;);  &#125;&#125;</code></pre></li></ul><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>前面学习的还是太慢了，记录的时候也不知道是详细一些好还是简单一些，就随便记了一下。算是了解一下如何写博客，希望自己能够养成学习的同时记录博客的好习惯。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客_note</title>
    <link href="/2020/08/23/Blog%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2020/08/23/Blog%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-Blog-Tag"><a href="#Hexo-Blog-Tag" class="headerlink" title="Hexo Blog Tag"></a>Hexo Blog Tag</h1><h2 id="关于修改"><a href="#关于修改" class="headerlink" title="关于修改"></a>关于修改</h2><pre><code class="hljs bash">利用VScode打开 E:\1_Web前端\blog\<span class="hljs-built_in">source</span>\_data\fluid_config.yml 进行修改</code></pre><h2 id="关于保存"><a href="#关于保存" class="headerlink" title="关于保存"></a>关于保存</h2><pre><code class="hljs bash">打开Git Bashhexo g    hexo d    hexo s(启动本地服务器)</code></pre><h2 id="本地访问与编辑"><a href="#本地访问与编辑" class="headerlink" title="本地访问与编辑"></a>本地访问与编辑</h2><pre><code class="hljs bash">本地地址：http://localhost:4000在线编辑视窗：http://localhost:4000/admin （本地hexo博客地址 + admin即可）</code></pre><h6 id="相关网址："><a href="#相关网址：" class="headerlink" title="相关网址："></a>相关网址：</h6><p><a href="https://hexo.io/docs/">hexo官方文档</a><br><a href="https://hexo.fluid-dev.com/docs/">fluid用户文档</a><br><a href="https://imgchr.com/">路过图床</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
